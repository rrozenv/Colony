"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const discovery_1 = require("./discovery");
const Realm = require("realm");
const _ = require("lodash");
const Logger_1 = require("./shared/Logger");
const Token_1 = require("./shared/Token");
const errors = require("./errors");
const RealmFactory_1 = require("./RealmFactory");
const stats_1 = require("./stats");
const pathMatcher_1 = require("./shared/pathMatcher");
const shared_1 = require("./shared");
const featureToken_1 = require("./shared/featureToken");
const Express = require("express");
const http = require("http");
const https = require("https");
const bodyParser = require("body-parser");
const morgan = require("morgan");
const fs = require("fs-extra");
const path = require("path");
const url = require("url");
const URI = require("urijs");
const NodeRSA = require("node-rsa");
class ServerValidationError extends Error {
}
exports.ServerValidationError = ServerValidationError;
class ServerStartError extends Error {
}
exports.ServerStartError = ServerStartError;
class ServerConfiguration {
}
exports.ServerConfiguration = ServerConfiguration;
var ServiceState;
(function (ServiceState) {
    ServiceState[ServiceState["Created"] = 0] = "Created";
    ServiceState[ServiceState["Starting"] = 1] = "Starting";
    ServiceState[ServiceState["Running"] = 2] = "Running";
    ServiceState[ServiceState["Stopping"] = 3] = "Stopping";
    ServiceState[ServiceState["Stopped"] = 4] = "Stopped";
})(ServiceState = exports.ServiceState || (exports.ServiceState = {}));
const realmFeatureToken = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJTeW5jIjp0cnVlLCJpYXQiOjE0OTI2MTEzMjl9.ixnaKuxOc3AUF0-h4g5Xy9OXIg1caEEdjjehz-2kweVZcBZvmmZ59oCsdJsDCemzQnGDqcfGLDsLa5S3RseNFUeYBsDHzdg3wyYRvKuEb9Va1qwjtfIearnU0n8-X5c_M8gUjmv6f22SLVjHptRFxudRmm5ej4AP1v2eyU_hCkQgTAk9twva4xDrdJX9VKGeA2QWwetbk2BnTIuW_rzJcTAD5eAw3fyKQXbxvEte7RqStYcP7gS02uiLxWJeZ_liIoO-SOq-ySwInb8NlhMJN8jWHp-cDoRGVHwTIhyK6IkKWkkymnhDAV4BitYbaK1pY05-5IOF4v8OXXVRmZav4A";
class Server {
    constructor(config = {}) {
        this.version = require('../package.json').version;
        this.config = config;
        this.services = [];
    }
    get started() {
        return this._started;
    }
    get dataPath() {
        return this.runningParams.dataPath;
    }
    get discovery() {
        return this.runningParams.discovery;
    }
    get logger() {
        return this.runningParams ? this.runningParams.logger : undefined;
    }
    get publicKeyPath() {
        return this.runningParams.publicKeyPath;
    }
    get privateKeyPath() {
        return this.runningParams.privateKeyPath;
    }
    start(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.runningParams !== undefined) {
                throw new Error('The server has already been started.');
            }
            if (!params.discovery) {
                params.discovery = new discovery_1.SingleProcessDiscovery();
            }
            if (!params.logger) {
                params.logger = new Logger_1.Console(params.logLevel || "info");
            }
            this.runningParams = yield this.validateStartParams(params);
            this.statsSink = this.statsStorage = new stats_1.SimpleStats();
            const featureTokenInfo = featureToken_1.loadFeatureToken(process.env.ROS_FEATURE_TOKEN);
            this.logger.info("Loaded feature token", featureTokenInfo);
            Realm.Sync.setSyncLogger((level, message) => {
                const syncLogLevel = Logger_1.SyncLogLevel[level];
                const mapping = ["all", "trace", "debug", "detail", "detail", "detail", "detail", "detail", "detail"];
                const realLevel = mapping[level];
                if (this.runningParams) {
                    this.logger[realLevel](`sync-client: ${message}`, { level: syncLogLevel });
                }
            });
            this.logger.info(`Realm Object Server version ${this.version} is starting`);
            this.privateKey = yield fs.readFile(params.privateKeyPath, 'utf-8');
            this.publicKey = yield fs.readFile(params.publicKeyPath, 'utf-8');
            this.adminToken = Token_1.generateAdminToken(this.privateKey);
            this.realmFactory = new RealmFactory_1.RealmFactory(this);
            yield this.injectLogger();
            this.expressApp = Express();
            this.expressApp.use(bodyParser.json());
            if (params.middlewares) {
                this.expressApp.use(params.middlewares);
            }
            this.httpServer = http.createServer(this.expressApp);
            this.httpServer.on('upgrade', this.upgradeHandler.bind(this));
            if (params.https) {
                const key = yield fs.readFile(params.httpsKeyPath);
                try {
                    new NodeRSA(key);
                }
                catch (_a) {
                    throw new ServerStartError(`Could not create HTTPS server: Private key is malformed.`);
                }
                const cert = yield fs.readFile(params.httpsCertChainPath, "utf-8");
                const regex = /-+BEGIN CERTIFICATE-+([\s\S]+?)-+END CERTIFICATE-+/;
                if (!regex.test(cert)) {
                    throw new ServerStartError(`Could not create HTTPS server: Certificate is malformed.`);
                }
                try {
                    this.httpsServer = https.createServer({ key, cert }, this.expressApp);
                }
                catch (err) {
                    throw new ServerStartError(`Could not create HTTPS server: ${err.stack}`);
                }
                this.httpsServer.on('upgrade', this.upgradeHandler.bind(this));
            }
            this.httpAccessLogger = this.logger.withContext({ service: 'http' });
            this.expressApp.use(morgan("short", { "stream": { write: (msg) => { this.httpAccessLogger.info(msg.trim()); } } }));
            this.expressApp.use(this.authenticationMiddleware.bind(this));
            yield shared_1.Promisify(this.httpServer.listen.bind(this.httpServer), params.port, params.address);
            if (this.httpsServer) {
                yield shared_1.Promisify(this.httpsServer.listen.bind(this.httpsServer), params.httpsPort, params.httpsAddress);
            }
            yield this.startServices();
            this.logger.detail("All services have started");
            this.expressApp.use(this.errorHandler.bind(this));
            this._started = true;
            const address = this.httpServer.address();
            for (let service of this.services) {
                const serverStartedFunctionName = Reflect.get(service, 'serverStartedFunctionName');
                if (serverStartedFunctionName) {
                    yield Promise.resolve(service[serverStartedFunctionName](this));
                }
            }
            const listeningOn = [`http://${address.address}:${address.port}`];
            if (this.httpsServer) {
                const httpsAddress = this.httpsServer.address();
                listeningOn.push(`https://${httpsAddress.address}:${httpsAddress.port}`);
            }
            this.logger.info(`Realm Object Server has started and is listening on ${listeningOn.join(" and ")}`);
        });
    }
    get address() {
        if (this.httpServer) {
            const address = this.httpServer.address();
            return `${address.address}:${address.port}`;
        }
    }
    get secureAddress() {
        if (this.httpsServer) {
            const address = this.httpsServer.address();
            return `${address.address}:${address.port}`;
        }
    }
    shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.stopServices();
            if (this.httpServer) {
                yield shared_1.Promisify(this.httpServer.close.bind(this.httpServer)).catch((err) => { });
            }
            if (this.httpsServer) {
                yield shared_1.Promisify(this.httpsServer.close.bind(this.httpsServer)).catch((err) => { });
            }
            if (this.realmFactory) {
                yield this.realmFactory.close();
                delete this.realmFactory;
            }
            if (this.logger) {
                this.logger.info("Realm Object Server has stopped");
            }
            delete this.runningParams;
            delete this.httpServer;
            if (this.httpsServer) {
                delete this.httpsServer;
            }
            delete this.expressApp;
        });
    }
    addServices(...services) {
        services.forEach(s => this.addService(s));
        return this;
    }
    addService(service, config) {
        if (this.started) {
            throw new Error('Services can only be added before starting the server.');
        }
        const Services = require("./services");
        let instance = typeof (service) === 'string' ?
            new Services[service](config) : service;
        this.services.push(instance);
        return this;
    }
    removeService(service) {
        if (this.started) {
            throw new Error('Services can only be added before starting the server.');
        }
        if (typeof service === 'string') {
            let survivingServices = [];
            for (let instance of this.services) {
                let serviceName = Reflect.get(instance.constructor, 'serviceName');
                if (serviceName !== service) {
                    survivingServices.push(service);
                }
            }
            this.services = survivingServices;
        }
        else {
            const index = this.services.indexOf(service);
            if (index > -1) {
                this.services.splice(index, 1);
            }
        }
        return this;
    }
    getService(name) {
        return this.services.find((s) => Reflect.get(s.constructor, 'serviceName') === name);
    }
    upgradeHandler(req, socket, head) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestPath = url.parse(req.url).path;
            let numberOfMatches = 0;
            for (let service of this.services) {
                let baseRoute = Reflect.get(service.constructor, 'baseRoute');
                if (!baseRoute) {
                    continue;
                }
                let upgradeRoutes = Reflect.get(service, 'upgradeRoutes') || [];
                if (upgradeRoutes.length === 0) {
                    continue;
                }
                for (let upgradeRoute of upgradeRoutes) {
                    let concatenatedServicePath = baseRoute;
                    if (upgradeRoute.path !== '/') {
                        concatenatedServicePath = URI.joinPaths(baseRoute, upgradeRoute.path).toString();
                    }
                    const params = pathMatcher_1.pathMatcher(concatenatedServicePath, requestPath);
                    if (params === false) {
                        continue;
                    }
                    req.params = params;
                    numberOfMatches = numberOfMatches + 1;
                    let parameterArguments = Reflect.get(service, 'parameterArguments') || [];
                    parameterArguments = parameterArguments.filter(p => p.functionName === upgradeRoute.functionName);
                    const handleError = (err) => {
                        if (err.status === 500) {
                            this.logger.error("Internal error in HTTP upgrade handler", err);
                        }
                        const problem = this.processException(err);
                        socket.write(`HTTP/1.1 ${problem.status}\r\nUpgrade Failed\r\n\r\n`);
                        socket.end();
                    };
                    try {
                        if (parameterArguments.length > 0) {
                            throw new Error('Decorator Annotations for @Uprade are not yet implemented');
                        }
                        const state = Reflect.get(service, "state");
                        if (state !== ServiceState.Running) {
                            throw new errors.realm.ServiceUnavailable();
                        }
                        const promise = service[upgradeRoute.functionName](req, socket, head);
                        if (promise instanceof Promise) {
                            yield promise.catch(handleError);
                        }
                    }
                    catch (err) {
                        handleError(err);
                    }
                }
            }
            if (numberOfMatches === 0) {
                socket.write('HTTP/1.1 404 Not Found\r\nUpgrade Failed\r\n\r\n');
                socket.end();
            }
        });
    }
    injectLogger() {
        return __awaiter(this, void 0, void 0, function* () {
            const promises = this.services.map((service) => {
                const promise = Promise.resolve();
                let functionName = Reflect.get(service, 'unmuteFunctionName');
                if (functionName && service[functionName]) {
                    promise.then(service[functionName](this.logger));
                }
                functionName = Reflect.get(service, 'unmuteContextualFunctionName');
                if (functionName && service[functionName]) {
                    const serviceName = Reflect.get(service.constructor, 'serviceName') || service.constructor.name;
                    promise.then(service[functionName](this.logger.withContext({ service: serviceName })));
                }
                return promise;
            });
            yield Promise.all(promises);
        });
    }
    addServiceEndpoints(service) {
        const baseRoute = Reflect.get(service.constructor, 'baseRoute');
        const routes = Reflect.get(service, 'routes') || [];
        const serviceStaticRoutes = Reflect.get(service, 'serveStaticRoutes') || [];
        if (serviceStaticRoutes.length === 0 && routes.length === 0) {
            return;
        }
        else if (!baseRoute) {
            throw new Error(`${service.constructor.name} does not have a base route`);
        }
        const router = Express.Router();
        const middlewares = Reflect.get(service.constructor, 'middlewaresBeforeService');
        if (middlewares) {
            router.use(middlewares);
        }
        router.use((req, res, next) => {
            const state = Reflect.get(service, "state");
            if (state !== ServiceState.Running) {
                throw new errors.realm.ServiceUnavailable();
            }
            next();
        });
        for (let serviceStaticRoute of serviceStaticRoutes) {
            router.use(serviceStaticRoute.path, Express.static(serviceStaticRoute.staticRoot));
        }
        for (let route of routes) {
            const m = Reflect.get(service, 'middlewaresBeforeFunction') || [];
            const middlewaresForThisFunction = m.filter(m => m.functionName === route.functionName);
            const middlewares = [].concat.apply([], middlewaresForThisFunction.map(x => x.middlewares));
            let handler = (req, res, next) => __awaiter(this, void 0, void 0, function* () {
                let functionName = route.functionName;
                let parameterArgumentMetaData = Reflect.get(service, 'parameterArguments') || [];
                parameterArgumentMetaData = parameterArgumentMetaData.filter(x => x.functionName === functionName);
                try {
                    if (parameterArgumentMetaData.length > 0) {
                        let args = [];
                        for (let p of parameterArgumentMetaData) {
                            switch (p.type) {
                                case 'body':
                                    args[p.argumentIndex] = p.keyPath ? _.get(req.body, p.keyPath) : req.body;
                                    break;
                                case 'query':
                                    args[p.argumentIndex] = p.keyPath ? _.get(req.query, p.keyPath) : req.query;
                                    break;
                                case 'headers':
                                    args[p.argumentIndex] = p.keyPath ? req.headers[p.keyPath.toLowerCase()] : req.headers;
                                    break;
                                case 'params':
                                    args[p.argumentIndex] = p.keyPath ? _.get(req.params, p.keyPath) : req.params;
                                    break;
                                case 'request':
                                    args[p.argumentIndex] = req;
                                    break;
                                case 'response':
                                    args[p.argumentIndex] = res;
                                    break;
                                case 'next':
                                    args[p.argumentIndex] = next;
                                    break;
                            }
                        }
                        let result = yield Promise.resolve(service[functionName](...args));
                        if (result) {
                            if (result.toJSON) {
                                res.json(result.toJSON());
                            }
                            else {
                                res.json(result);
                            }
                        }
                    }
                    else {
                        let result = yield Promise.resolve(service[functionName](req, res, next));
                        if (result) {
                            res.json(result);
                        }
                    }
                }
                catch (err) {
                    next(err);
                }
            });
            router[route.httpMethod](route.path, middlewares, handler);
        }
        this.expressApp.use(baseRoute, router);
    }
    startServices() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this.services.map(this.startService.bind(this)));
        });
    }
    startService(service) {
        return __awaiter(this, void 0, void 0, function* () {
            Reflect.set(service, "state", ServiceState.Starting);
            Reflect.set(service, "stats", this.statsSink);
            Reflect.set(service, "statsStorage", this.statsStorage);
            const serviceName = Reflect.get(service.constructor, "serviceName");
            if (serviceName) {
                this.logger.detail(`Starting service ${serviceName}`);
            }
            const startFunctionName = Reflect.get(service, 'startFunctionName');
            if (startFunctionName && service[startFunctionName]) {
                yield Promise.resolve(service[startFunctionName](this));
            }
            this.addServiceEndpoints(service);
            Reflect.set(service, "state", ServiceState.Running);
            let address;
            const addressFunctionName = Reflect.get(service, 'addressFunctionName');
            if (addressFunctionName) {
                address = service[addressFunctionName]();
            }
            else {
                address = this.httpServer.address();
            }
            yield this.discovery.registerService(service, address.address, address.port);
            if (serviceName) {
                this.logger.detail(`Started service ${serviceName}`);
            }
        });
    }
    stopServices() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this.services.reverse().map(this.stopService.bind(this)));
        });
    }
    stopService(service) {
        return __awaiter(this, void 0, void 0, function* () {
            Reflect.set(service, "state", ServiceState.Stopping);
            const serviceName = Reflect.get(service.constructor, "serviceName");
            if (serviceName) {
                this.logger.detail(`Stopping service ${serviceName}`);
            }
            yield this.discovery.deregisterService(service);
            const stopFunctionName = Reflect.get(service, 'stopFunctionName');
            if (stopFunctionName) {
                yield Promise.resolve(service[stopFunctionName]());
            }
            Reflect.set(service, "state", ServiceState.Stopped);
            if (serviceName) {
                this.logger.detail(`Stopped service ${serviceName}`);
            }
        });
    }
    authenticationMiddleware(req, res, next) {
        try {
            const authorization = req.headers['authorization'] || req.headers['x-realm-access-token'];
            if (authorization) {
                const tokenData = authorization;
                try {
                    req.authToken = Token_1.Token.parse(tokenData, this.publicKey);
                }
                catch (err) {
                    next(new errors.realm.InvalidCredentials());
                }
            }
        }
        catch (err) {
        }
        next();
    }
    processException(error) {
        if (error instanceof errors.JSONError) {
            return error;
        }
        else {
            const status = error.status || error.statusCode;
            if (status) {
                return new errors.JSONError({
                    status: status,
                    stack: error.stack,
                    title: error.message,
                });
            }
            this.logger.error(`Internal server error: ${error.stack}`);
            return new errors.JSONError({
                status: 500,
                stack: error.stack,
                title: 'Internal Server Error',
            });
        }
    }
    errorHandler(error, req, res, next) {
        if (res.headersSent) {
            next(error);
            return;
        }
        const jsonError = this.processException(error);
        res.setHeader('Content-Type', 'application/json');
        res.status(jsonError.status).json(jsonError.toJSON());
    }
    validateStartParams(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!params.address) {
                params.address = "0.0.0.0";
            }
            if (params.port === undefined) {
                params.port = 9080;
            }
            if (params.httpsPort === undefined) {
                params.httpsPort = 9443;
            }
            if (params.autoKeyGen === undefined) {
                params.autoKeyGen = true;
            }
            if (fs.existsSync(params.dataPath)) {
                const stat = fs.statSync(params.dataPath);
                if (!stat.isDirectory()) {
                    throw new ServerValidationError(`The data directory '${params.dataPath}' is not a directory`);
                }
                try {
                    fs.accessSync(params.dataPath, fs.constants.R_OK | fs.constants.W_OK | fs.constants.X_OK);
                }
                catch (e) {
                    throw new ServerValidationError(`The data directory '${params.dataPath}' does not have 'rwx' permissions`);
                }
            }
            else {
                try {
                    fs.mkdirSync(params.dataPath, 0o700);
                }
                catch (e) {
                    throw new ServerValidationError(`The data directory '${params.dataPath}' cannot be created.`);
                }
            }
            if (!params.privateKeyPath) {
                params.privateKeyPath = path.join(params.dataPath, "keys", "auth.key");
            }
            try {
                fs.openSync(params.privateKeyPath, 'r');
            }
            catch (e) {
                if (params.autoKeyGen) {
                    const key = new NodeRSA({ b: 2048 });
                    const keyData = key.exportKey("pkcs8-private-pem");
                    yield fs.mkdirp(path.dirname(params.privateKeyPath));
                    yield fs.writeFile(params.privateKeyPath, keyData);
                    const adminToken = Token_1.generateAdminToken(keyData);
                    const stringifiedJSON = JSON.stringify({
                        "ADMIN_TOKEN": adminToken
                    }, null, 4);
                    yield fs.writeFile(path.join(params.dataPath, "keys", "admin.json"), stringifiedJSON);
                }
                else {
                    throw new ServerValidationError(`The private key '${params.privateKeyPath}' does not exist or is not readable.`);
                }
            }
            if (!params.publicKeyPath) {
                params.publicKeyPath = path.join(params.dataPath, "keys", "auth.pub");
            }
            try {
                fs.openSync(params.publicKeyPath, 'r');
            }
            catch (e) {
                if (params.autoKeyGen) {
                    const privateKeyData = yield fs.readFile(params.privateKeyPath);
                    const privateKey = new NodeRSA(privateKeyData);
                    const keyData = privateKey.exportKey("pkcs8-public-pem");
                    yield fs.mkdirp(path.dirname(params.publicKeyPath));
                    yield fs.writeFile(params.publicKeyPath, keyData);
                }
                else {
                    throw new ServerValidationError(`The private key '${params.publicKeyPath}' does not exist or is not readable.`);
                }
            }
            if (params.https) {
                if (!params.httpsKeyPath) {
                    throw new ServerValidationError("HTTPS was enabled but a path to the key was not provided.");
                }
                try {
                    fs.openSync(params.httpsKeyPath, 'r');
                }
                catch (e) {
                    throw new ServerValidationError("The HTTPS key could not be read.");
                }
                if (!params.httpsCertChainPath) {
                    throw new ServerValidationError("HTTPS was enabled but a path to the certificate chain was not provided.");
                }
                try {
                    fs.openSync(params.httpsCertChainPath, 'r');
                }
                catch (e) {
                    throw new ServerValidationError("The HTTPS certificate chain could not be read.");
                }
                if (!params.httpsPort) {
                    params.httpsPort = 0;
                }
                if (!params.httpsAddress) {
                    params.httpsAddress = "0.0.0.0";
                }
            }
            return params;
        });
    }
    openRealm(remoteRealmPath, schema) {
        return this.realmFactory.open({
            remotePath: remoteRealmPath,
            schema: schema
        });
    }
}
exports.Server = Server;
//# sourceMappingURL=Server.js.map