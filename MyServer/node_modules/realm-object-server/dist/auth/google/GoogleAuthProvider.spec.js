"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const superagent = require("superagent");
const superagentMock = require("superagent-mock");
const GoogleAuthProvider_1 = require("./GoogleAuthProvider");
const errors = require("../../errors");
const TestServer_1 = require("../../TestServer");
const clientId = '407408718192.apps.googleusercontent.com';
const validAccessToken = 'eyJhbGciOiJSUzI1NiIsImtpZCI6IjhiNmE3ZDhhM2I0NTQ4YWU1MjBmZDJkMTY2ZWEzN2U2ZGRjY2JkOWYifQ.eyJhenAiOiI0MDc0MDg3MTgxOTIuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiI0MDc0MDg3MTgxOTIuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMDEwNDkwODM2MjMyMzM0NTk5NjMiLCJhdF9oYXNoIjoibU5pbFRfdEtuRWNuY3hVODhUQW5udyIsImlzcyI6Imh0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbSIsImlhdCI6MTUwNTkyODUxMSwiZXhwIjoxNTA1OTMyMTExLCJuYW1lIjoiQWRhbSBGaXNoIiwicGljdHVyZSI6Imh0dHBzOi8vbGg2Lmdvb2dsZXVzZXJjb250ZW50LmNvbS8teXdyM3F3VWx3ejQvQUFBQUFBQUFBQUkvQUFBQUFBQUFBSG8vWGs2RkFtVnBqb2cvczk2LWMvcGhvdG8uanBnIiwiZ2l2ZW5fbmFtZSI6IkFkYW0iLCJmYW1pbHlfbmFtZSI6IkZpc2giLCJsb2NhbGUiOiJlbiJ9.jiWVeVHoYPJXyn6uz7tABmP0V2Bgv3v0NKnQTdxNBKO1f8FF_MiRxgPLusJrmLCfP4c7EQUGnj_0zMtCACCX_tw1Z789UeR2B0-UOciVfej8TNL94DvkPaVXsRk53E_IeYg9wN1kO5U5aFCnksD5xIt5EO5Ba9fgWSQyl5GIWAe_C-kPRuOqmD0A8zo_EQJPMwEJc9AxyvfFLYR5f7cM5VXFBOmIOFzfd4Ld-ol4_ddJDNM9FdwfXtOBL2cm8KUYdvskK-Y9uHs5xHcmgRSi72198PbCFGIXW-z8Y4aRSyMEqt4SaymExmZhSIA9AZgxZfueWpVEfLZwCuWgPteK5g';
describe("GoogleAuthProvider", () => {
    let provider;
    let server;
    let authService;
    function createServer(params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            server = new TestServer_1.TestServer();
            provider = new GoogleAuthProvider_1.GoogleAuthProvider({
                clientId: clientId
            });
            yield server.start({
                authProviders: [provider]
            });
            authService = server.getService('auth');
        });
    }
    let mock;
    function mockToken(token, response) {
        mock = superagentMock(superagent, [{
                pattern: "https://www.googleapis.com(.*)",
                get: function (match, data) {
                    return {
                        code: 200,
                        body: data,
                    };
                },
                fixtures: function (match, params, headers, context) {
                    if (match[1] === `/oauth2/v3/tokeninfo?id_token=${token}`) {
                        return response;
                    }
                },
            }]);
    }
    afterEach(() => {
        if (mock) {
            mock.unset();
            mock = null;
        }
    });
    before(() => __awaiter(this, void 0, void 0, function* () { return createServer(); }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown();
    }));
    describe("authenticateOrCreateUser", () => {
        describe("without data param", () => {
            it("should return a MissingParameters exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({}), errors.realm.MissingParameters);
            }));
        });
        describe("with invalid access token", () => {
            it("should return an InvalidCredentials exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: "isInvalid" }), errors.realm.InvalidCredentials);
            }));
        });
        describe("with undefined userId", () => {
            it("should reject with error", () => __awaiter(this, void 0, void 0, function* () {
                mockToken(validAccessToken, {
                    aud: "407408718192.apps.googleusercontent.com",
                    exp: Math.floor(Date.now() / 1000) - 600,
                });
                const user = yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: validAccessToken }), "The provided credentials are invalid or the user does not exist.");
            }));
        });
        describe("with expired token", () => {
            it("should reject with error", () => __awaiter(this, void 0, void 0, function* () {
                mockToken(validAccessToken, {
                    sub: "114510788383289011376",
                    aud: "407408718192.apps.googleusercontent.com",
                    exp: Math.floor(Date.now() / 1000) - 600,
                });
                const user = yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: validAccessToken }), "The provided credentials are invalid or the user does not exist.");
            }));
        });
        describe("with wrong clientId", () => {
            it("should reject with error", () => __awaiter(this, void 0, void 0, function* () {
                mockToken(validAccessToken, {
                    sub: "114510788383289011376",
                    aud: "1234567890.apps.googleusercontent.com",
                    exp: Math.floor(Date.now() / 1000) + 600,
                });
                const user = yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: validAccessToken }), "The provided credentials are invalid or the user does not exist.");
            }));
        });
        describe("with valid token", () => {
            it("should return a user", () => __awaiter(this, void 0, void 0, function* () {
                mockToken(validAccessToken, {
                    sub: "114510788383289011376",
                    aud: "407408718192.apps.googleusercontent.com",
                    exp: Math.floor(Date.now() / 1000) + 600,
                });
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validAccessToken }));
                chai_1.assert.isTrue(user.created);
                chai_1.assert.isDefined(user.userId);
                chai_1.assert.isFalse(user.isAdmin);
                chai_1.assert.equal(user.accounts[0].provider, "google");
                chai_1.assert.isDefined(user.accounts[0].providerId);
                chai_1.assert.notEqual(user.accounts[0].providerId, validAccessToken);
            }));
        });
        describe("on subsequent requests", () => {
            it("should return a user", () => __awaiter(this, void 0, void 0, function* () {
                mockToken(validAccessToken, {
                    sub: "114510788383289011376",
                    aud: "407408718192.apps.googleusercontent.com",
                    exp: Math.floor(Date.now() / 1000) + 600,
                });
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validAccessToken }));
                const secondUser = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validAccessToken }));
                chai_1.assert.equal(user.userId, secondUser.userId);
                chai_1.assert.equal(user.accounts[0].providerId, secondUser.accounts[0].providerId);
            }));
        });
    });
});
//# sourceMappingURL=GoogleAuthProvider.spec.js.map