"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const sinon = require("sinon");
const path = require("path");
const superagent = require("superagent");
const superagentMock = require("superagent-mock");
const CloudkitAuthProvider_1 = require("./CloudkitAuthProvider");
const errors = require("../../errors");
const TestServer_1 = require("../../TestServer");
describe("CloudkitAuthProvider", () => {
    let provider;
    let server;
    let authService;
    function createServer(params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            server = new TestServer_1.TestServer();
            provider = new CloudkitAuthProvider_1.CloudkitAuthProvider({
                container: "iCloud.io.realm.realmtasks.ios",
                keyId: "94938c4a9cf6770491bafea8dcf252f9712b748479d8ad6c84344186746accfb",
                privateKeyPath: path.join(__dirname, "..", "..", "..", "fixtures", "cloudkit_eckey.pem"),
                environment: "development"
            });
            yield server.start({
                authProviders: [provider]
            });
            authService = server.getService('auth');
        });
    }
    afterEach(() => __awaiter(this, void 0, void 0, function* () {
        if (server) {
            yield server.shutdown();
        }
    }));
    let mock;
    const validUserIds = ["_bc5eca430b7597a64745b454b002faf7", "_bc5eca430b7597a64745b454b002faf8"];
    before(() => {
        mock = superagentMock(superagent, [{
                pattern: "https://api.apple-cloudkit.com(.*)",
                post: function (match, data) {
                    return {
                        code: 200,
                        body: data,
                    };
                },
                fixtures: function (match, params, headers, context) {
                    if (match[1] === '/database/1/iCloud.io.realm.realmtasks.ios/development/public/users/discover') {
                        const paramsData = JSON.parse(params);
                        const userRecordName = paramsData.lookupInfos[0].userRecordName;
                        if (validUserIds.indexOf(userRecordName) === -1) {
                            const err = new Error();
                            err.response = {
                                body: {
                                    reason: "No valid user ids to lookup",
                                }
                            };
                            throw err;
                        }
                        else {
                            return {
                                users: [{
                                        lookupInfo: { userRecordName }
                                    }]
                            };
                        }
                    }
                },
            }]);
    });
    after(() => {
        mock.unset();
    });
    describe("authenticateOrCreateUser", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () { return createServer(); }));
        describe("without data param", () => {
            it("should return a MissingParameters exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({}), errors.realm.MissingParameters);
            }));
        });
        describe("with invalid user record name", () => {
            it("should return an InvalidCredentials exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: "isInvalid" }), errors.realm.InvalidCredentials);
            }));
        });
        describe("on first request", () => {
            it("should return a user", () => __awaiter(this, void 0, void 0, function* () {
                const requestSpy = sinon.spy(provider, "signedRequest");
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validUserIds[0] }));
                chai_1.assert.isTrue(user.created);
                chai_1.assert.isDefined(user.userId);
                chai_1.assert.isFalse(user.isAdmin);
                chai_1.assert.equal(user.accounts[0].provider, "cloudkit");
                chai_1.assert.equal(user.accounts[0].providerId, validUserIds[0]);
                sinon.assert.calledOnce(requestSpy);
            }));
        });
        describe("on subsequent requests", () => {
            it("should return a user", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validUserIds[1] }));
                const requestSpy = sinon.spy(provider, "signedRequest");
                yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validUserIds[1] }));
                sinon.assert.notCalled(requestSpy);
            }));
        });
    });
});
//# sourceMappingURL=CloudkitAuthProvider.spec.js.map