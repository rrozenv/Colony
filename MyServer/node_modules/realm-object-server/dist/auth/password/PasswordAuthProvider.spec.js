"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const faker = require("faker");
const PasswordAuthProvider_1 = require("./PasswordAuthProvider");
const __1 = require("..");
const errors = require("../../errors");
const TestServer_1 = require("../../TestServer");
describe("PasswordAuthProvider", () => {
    let provider;
    let server;
    let authService;
    function createServer(params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            server = new TestServer_1.TestServer();
            provider = new PasswordAuthProvider_1.PasswordAuthProvider(Object.assign(params, { iterations: 1 }));
            yield server.start({
                authProviders: [provider],
            });
            authService = server.getService('auth');
        });
    }
    afterEach(() => __awaiter(this, void 0, void 0, function* () {
        if (server) {
            yield server.shutdown();
        }
    }));
    describe("password functions", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () { return createServer(); }));
        it('should be able to create a salt with the configured provider.iterations', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const buffer = yield provider['createSalt'](provider.iterations);
                chai_1.expect(buffer).to.not.be.empty;
            });
        });
        it('should be able to compare a password ', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const salt = yield provider['createSalt'](provider.saltLength);
                const hash = yield provider['hashPassword']('iloverealm', salt, provider.iterations, provider.keyLength, provider.digest);
                const isMatch = yield provider['comparePassword']('iloverealm', salt, provider.iterations, provider.keyLength, provider.digest, hash);
                chai_1.expect(isMatch).to.be.true;
            });
        });
        it('should be false when comparing a bad password', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const salt = yield provider['createSalt'](provider.saltLength);
                const hash = yield provider['hashPassword']('iloverealm', salt, provider.iterations, provider.keyLength, provider.digest);
                const isMatch = yield provider['comparePassword']('bad password', salt, provider.iterations, provider.keyLength, provider.digest, hash);
                chai_1.expect(isMatch).to.be.false;
            });
        });
        it('should be false when changing the digest method', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const salt = yield provider['createSalt'](provider.saltLength);
                const hash = yield provider['hashPassword']('iloverealm', salt, provider.iterations, provider.keyLength, 'sha512');
                const isMatch = yield provider['comparePassword']('iloverealm', salt, provider.iterations, provider.keyLength, 'sha256', hash);
                chai_1.expect(isMatch).to.be.false;
            });
        });
        it('should be false when changing the iterations', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const salt = yield provider['createSalt'](provider.saltLength);
                const hash = yield provider['hashPassword']('iloverealm', salt, provider.iterations, provider.keyLength, provider.digest);
                const isMatch = yield provider['comparePassword']('iloverealm', salt, provider.iterations + 5, provider.keyLength, provider.digest, hash);
                chai_1.expect(isMatch).to.be.false;
            });
        });
        it('should be false when changing the keyLength', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const salt = yield provider['createSalt'](provider.saltLength);
                const hash = yield provider['hashPassword']('iloverealm', salt, provider.iterations, provider.keyLength, provider.digest);
                const isMatch = yield provider['comparePassword']('iloverealm', salt, provider.iterations, provider.keyLength + 123, provider.digest, hash);
                chai_1.expect(isMatch).to.be.false;
            });
        });
    });
    describe("authenticateOrCreateUser", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () { return createServer(); }));
        it("should throw an error when a username is not passed", () => __awaiter(this, void 0, void 0, function* () {
            yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({}), errors.realm.MissingParameters);
        }));
        it("should throw an error when a password is not passed", () => __awaiter(this, void 0, void 0, function* () {
            yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({
                username: 'user1',
            }), errors.realm.MissingParameters);
        }));
        it("should throw an error when register not provided or false", () => __awaiter(this, void 0, void 0, function* () {
            yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({
                username: 'user1',
                password: "mypassword"
            }), errors.realm.InvalidCredentials);
        }));
        it("should fulfill when register is true", () => __awaiter(this, void 0, void 0, function* () {
            yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({
                username: 'user1',
                password: "mypassword",
                register: true,
            }));
        }));
    });
    describe("update", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () { return createServer(); }));
        let username;
        let user;
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            username = faker.internet.userName();
            user = yield authService.createOrUpdateUser(username, "password", false);
        }));
        it("should raise an error when new_password is not passed", () => __awaiter(this, void 0, void 0, function* () {
            yield chai_1.assert.isRejected(provider.update(user, {
                currentPassword: "oldPassword"
            }), errors.realm.MissingParameters);
        }));
        it("should change the user's password", () => __awaiter(this, void 0, void 0, function* () {
            yield chai_1.assert.isFulfilled(provider.update(user, {
                new_password: "Rod.Smith"
            }));
            yield chai_1.assert.isFulfilled(provider['attemptToLogin'](username, 'Rod.Smith'));
        }));
    });
    describe("autoCreateAdminUser", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () { return createServer({ autoCreateAdminUser: true }); }));
        it('should create realm-admin upon autokeygen', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const realmAdminUser = authService.getUserByProviderId("password", "realm-admin");
                chai_1.assert.isDefined(realmAdminUser);
                chai_1.assert.isTrue(realmAdminUser.isAdmin);
                chai_1.assert.equal(realmAdminUser.accounts[0].provider, 'password');
                chai_1.assert.equal(realmAdminUser.accounts[0].providerId, 'realm-admin');
                const loggedInUser = yield provider["attemptToLogin"]('realm-admin', '');
                chai_1.assert.isDefined(loggedInUser);
                chai_1.assert.equal(loggedInUser.userId, realmAdminUser.userId);
                chai_1.assert.equal(loggedInUser.accounts[0].provider, 'password');
                chai_1.assert.equal(loggedInUser.accounts[0].providerId, 'realm-admin');
                chai_1.assert.isTrue(loggedInUser.isAdmin);
            });
        });
    });
    describe("createUserChangePasswordHashParametersLoginUser", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () { return createServer(); }));
        it('should login after changing password hash parameters', function () {
            return __awaiter(this, void 0, void 0, function* () {
                const user_1 = yield provider.authenticateOrCreateUser({
                    username: 'some name',
                    password: "mypassword",
                    register: true,
                });
                chai_1.assert.equal(user_1.accounts.length, 1);
                chai_1.assert.equal(user_1.accounts[0].provider, "password");
                chai_1.assert.equal(user_1.accounts[0].providerId, "some name");
                provider.iterations = 1000000;
                provider.keyLength = 123;
                provider.digest = 'sha256';
                const user_2 = yield provider.authenticateOrCreateUser({
                    username: 'some name',
                    password: "mypassword",
                    register: false,
                });
                chai_1.assert.equal(user_1.userId, user_2.userId);
            });
        });
    });
    describe("deleteUser", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () { return createServer(); }));
        it('Password Realm should be empty after creating a user and deleting it', () => __awaiter(this, void 0, void 0, function* () {
            const user = yield provider.authenticateOrCreateUser({
                username: 'some name',
                password: "mypassword",
                register: true,
            });
            const realm = provider['passwordRealm'];
            const foundPasswordBefore = realm.objectForPrimaryKey('PasswordSaltHash', user.userId);
            chai_1.assert.exists(foundPasswordBefore);
            const userDeleted = yield provider.deleteUser(user.userId);
            chai_1.assert.isTrue(userDeleted);
            const userDeletedAgain = yield provider.deleteUser(user.userId);
            chai_1.assert.isFalse(userDeletedAgain);
            const foundPasswordAfter = realm.objectForPrimaryKey('PasswordSaltHash', user.userId);
            chai_1.assert.notExists(foundPasswordAfter);
        }));
    });
    describe("createUserChangePasswordHashParametersLoginUser", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () { return createServer(); }));
        it('should fail when the user attempts to login after the password is deleted from the password Realm', () => __awaiter(this, void 0, void 0, function* () {
            const user = yield provider.authenticateOrCreateUser({
                username: 'some name',
                password: "mypassword",
                register: true,
            });
            chai_1.assert.equal(user.accounts.length, 1);
            chai_1.assert.equal(user.accounts[0].provider, "password");
            chai_1.assert.equal(user.accounts[0].providerId, "some name");
            const userDeleted = yield provider.deleteUser(user.userId);
            chai_1.assert.isTrue(userDeleted);
            yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({
                username: 'some name',
                password: "mypassword",
                register: false,
            }));
        }));
    });
});
describe('UserLoginWIthWrongProvider', () => {
    it('should fail when a debug user attempts to log in with the password provider', () => __awaiter(this, void 0, void 0, function* () {
        const passwordProvider = new PasswordAuthProvider_1.PasswordAuthProvider({ iterations: 5 });
        const debugProvider = new __1.DebugAuthProvider();
        const server = new TestServer_1.TestServer();
        yield server.start({
            authProviders: [
                passwordProvider,
                debugProvider,
            ]
        });
        const authService = server.getService('auth');
        const user = yield debugProvider.authenticateOrCreateUser({
            data: 'some name',
        });
        chai_1.assert.equal(user.accounts.length, 1);
        chai_1.assert.equal(user.accounts[0].provider, "debug");
        chai_1.assert.equal(user.accounts[0].providerId, "some name");
        yield chai_1.assert.isRejected(passwordProvider.authenticateOrCreateUser({
            username: 'some name',
            password: "mypassword",
            register: false,
        }));
        yield server.shutdown();
    }));
});
//# sourceMappingURL=PasswordAuthProvider.spec.js.map