"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const superagent = require("superagent");
const superagentMock = require("superagent-mock");
const FacebookAuthProvider_1 = require("./FacebookAuthProvider");
const errors = require("../../errors");
const TestServer_1 = require("../../TestServer");
const validAccessToken = 'EAACRlUPa8hQBAPvaEjlfjsW7i8D06Boqfu1faZCCyxVizLsHMgK0qZB7nirZADJCsuJNOja9231C3r4nEiILdmZCgaIwmkfEwTxJ3vLMVehA8TgiZC2H357sZCkzLdqeEionr68LpZAcACjZCWMuV9zYUePWbLH6UGdRho3YiZC8TrjONJgZAd7dJA65oHS8Dj9DIcyOis1wsLO4gb2FV4ZCuHQhtRuywJGZCRE7a9UMZAPYXgAZDZD';
describe("FacebookAuthProvider", () => {
    let provider;
    let server;
    let authService;
    function createServer(params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            server = new TestServer_1.TestServer();
            provider = new FacebookAuthProvider_1.FacebookAuthProvider();
            yield server.start({
                authProviders: [provider]
            });
            authService = server.getService('auth');
        });
    }
    before(() => __awaiter(this, void 0, void 0, function* () { return createServer(); }));
    after(() => __awaiter(this, void 0, void 0, function* () { return server.shutdown(); }));
    let mock;
    function mockToken(token, response) {
        mock = superagentMock(superagent, [{
                pattern: "https://graph.facebook.com(.*)",
                get: function (match, data) {
                    return {
                        code: 200,
                        body: data,
                    };
                },
                fixtures: function (match, params, headers, context) {
                    if (match[1] === `/me?access_token=${token}`) {
                        return response;
                    }
                },
            }]);
    }
    afterEach(() => {
        if (mock) {
            mock.unset();
            mock = null;
        }
    });
    describe("authenticateOrCreateUser", () => {
        describe("without data param", () => {
            it("should return a MissingParameters exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({}), errors.realm.MissingParameters);
            }));
        });
        describe("with invalid access token", () => {
            it("should return an InvalidCredentials exception", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: "isInvalid" }), errors.realm.InvalidCredentials);
            }));
        });
        describe("with invalid user", () => {
            it("should reject", () => __awaiter(this, void 0, void 0, function* () {
                mockToken(validAccessToken, {});
                const user = yield chai_1.assert.isRejected(provider.authenticateOrCreateUser({ data: validAccessToken }), "The provided credentials are invalid or the user does not exist.");
            }));
        });
        describe("on first request", () => {
            it("should return a user", () => __awaiter(this, void 0, void 0, function* () {
                mockToken(validAccessToken, {
                    id: 'some id',
                });
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validAccessToken }));
                chai_1.assert.isTrue(user.created);
                chai_1.assert.isDefined(user.userId);
                chai_1.assert.isFalse(user.isAdmin);
                chai_1.assert.equal(user.accounts[0].provider, "facebook");
                chai_1.assert.isDefined(user.accounts[0].providerId);
                chai_1.assert.notEqual(user.accounts[0].providerId, validAccessToken);
            }));
        });
        describe("on subsequent requests", () => {
            it("should return a user", () => __awaiter(this, void 0, void 0, function* () {
                mockToken(validAccessToken, {
                    id: 'some id 2',
                });
                const user = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validAccessToken }));
                const secondUser = yield chai_1.assert.isFulfilled(provider.authenticateOrCreateUser({ data: validAccessToken }));
                chai_1.assert.equal(user.userId, secondUser.userId);
                chai_1.assert.equal(user.accounts[0].providerId, secondUser.accounts[0].providerId);
            }));
        });
    });
});
//# sourceMappingURL=FacebookAuthProvider.spec.js.map