#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Realm = require("realm");
const path = require("path");
const fs = require("fs-extra");
const JSONStream = require("JSONStream");
const minimist = require("minimist");
const virtPath_1 = require("../shared/virtPath");
const adminSchema = [
    {
        name: 'UserMetadataRow',
        properties: {
            user: { type: 'linkingObjects', objectType: 'User', property: 'metadata' },
            key: { type: 'string', optional: false },
            value: { type: 'string', optional: false },
        },
    },
    {
        name: 'User',
        primaryKey: 'userId',
        properties: {
            userId: { type: 'string', optional: false },
            isAdmin: { type: 'bool', optional: false },
            accounts: { type: "list", objectType: "Account" },
            metadata: { type: 'list', objectType: 'UserMetadataRow', default: [], optional: false },
        },
    },
    {
        name: 'Account',
        properties: {
            provider: { type: 'string', optional: false, indexed: true },
            providerId: { type: "string", optional: false, indexed: true },
            user: { type: 'linkingObjects', objectType: 'User', property: 'accounts' },
        },
    },
    {
        name: 'Permission',
        properties: {
            user: { type: 'User' },
            realmFile: 'RealmFile',
            mayRead: { type: 'bool', optional: false },
            mayWrite: { type: 'bool', optional: false },
            mayManage: { type: 'bool', optional: false },
            updatedAt: { type: 'date', optional: false },
        },
    },
    {
        name: 'RealmFile',
        primaryKey: 'path',
        properties: {
            path: 'string',
            syncLabel: 'string',
            owner: { type: 'User', optional: true },
            createdAt: 'date',
            permissions: { type: 'linkingObjects', objectType: 'Permission', property: 'realmFile' },
        },
    },
];
const passwordSchema = [
    {
        name: 'PasswordSaltHash',
        primaryKey: 'userId',
        properties: {
            userId: { type: 'string', optional: false },
            salt: { type: 'string', optional: false },
            iterations: { type: 'int', optional: false },
            keyLength: { type: 'int', optional: false },
            digest: { type: 'string', optional: false },
            hash: { type: 'string', optional: false },
        },
    },
];
function importUser(user, adminRealm, passwordRealm) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(`user: ${user.id}`);
        adminRealm.write(() => {
            const userData = {
                userId: user.id,
                isAdmin: user.is_admin,
                accounts: user.accounts.map((a) => {
                    return { provider: a.provider, providerId: a.provider_id };
                }),
                metadata: [],
            };
            for (const nspace in user.metadata) {
                for (const k in user.metadata[nspace]) {
                    userData.metadata.push({
                        key: nspace + '.' + k,
                        value: user.metadata[nspace][k],
                    });
                }
            }
            const userObj = adminRealm.create('User', userData);
        });
        for (const a of user.accounts.filter((a) => a.provider === 'password')) {
            console.log(`password-provided account: ${user.id}`);
            const pwdata = JSON.parse(a.data);
            const options = {
                digest: 'sha256',
                iterations: 100000,
                keyLength: 512,
            };
            if (pwdata.options) {
                options.digest = pwdata.options.digest;
                options.iterations = pwdata.options.iterations;
                options.keyLength = pwdata.options.key_length;
            }
            passwordRealm.write(() => {
                passwordRealm.create('PasswordSaltHash', Object.assign({}, options, { userId: user.id, salt: pwdata.salt, hash: pwdata.password }));
            });
        }
    });
}
function importRealm(realm, adminRealm) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(`realm: ${realm.path}`);
        adminRealm.write(() => {
            let syncLabel = 'default';
            if (realm.cluster_node_id != null && realm.cluster_node_id !== '0') {
                syncLabel = realm.cluster_node_id;
            }
            adminRealm.create('RealmFile', {
                path: realm.path,
                owner: realm.owner_id ? adminRealm.objectForPrimaryKey('User', realm.owner_id) : null,
                createdAt: new Date(),
                syncLabel: syncLabel,
            });
        });
    });
}
function importPermission(permission, adminRealm) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(`permission to ${permission.user_id || 'everyone'} on realm ${permission.file_path}`);
        adminRealm.write(() => {
            const realmFile = adminRealm.objectForPrimaryKey('RealmFile', permission.file_path);
            if (!realmFile) {
                throw new Error(`cannot create permission on realm ${permission.file_path}: the realm does not exist`);
            }
            let user = null;
            if (permission.user_id) {
                user = adminRealm.objectForPrimaryKey('User', permission.user_id);
                if (!user) {
                    throw new Error(`cannot grant permission on realm ${permission.file_path} to user ${permission.user_id}: the user does not exist`);
                }
            }
            adminRealm.create('Permission', {
                user: user,
                realmFile: realmFile,
                mayRead: permission.may_read,
                mayWrite: permission.may_write,
                mayManage: permission.may_manage,
                updatedAt: new Date(),
            });
        });
    });
}
function importAdminJson(src, dsts, userRealmCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        const adminRealm = new Realm({
            path: dsts.admin,
            schema: adminSchema,
            sync: true,
        });
        const passwordRealm = new Realm({
            path: dsts.password,
            schema: passwordSchema,
            sync: true,
        });
        let [users, realms, permissions] = [0, 0, 0];
        const input = fs.createReadStream(src);
        const parser = JSONStream.parse([true, { emitPath: true }]);
        parser.on('data', (data) => __awaiter(this, void 0, void 0, function* () {
            const [collection, index] = data.path;
            parser.pause();
            switch (collection) {
                case 'users': {
                    yield importUser(data.value, adminRealm, passwordRealm);
                    users++;
                    break;
                }
                case 'permissions': {
                    yield importPermission(data.value, adminRealm);
                    permissions++;
                    break;
                }
                case 'realms': {
                    if (!virtPath_1.mapVirtToRealmPath("/", data.value.path)) {
                        console.log(`skipping a realm with invalid path: ${data.value.path}`);
                        break;
                    }
                    yield importRealm(data.value, adminRealm);
                    if (userRealmCallback) {
                        yield userRealmCallback(data.value);
                    }
                    realms++;
                    break;
                }
            }
            parser.resume();
        }));
        input.pipe(parser);
        yield new Promise((resolve, reject) => {
            parser.on('end', resolve);
        });
        passwordRealm.close();
        adminRealm.close();
        return { users, realms, permissions };
    });
}
function isEmptyDir(dir) {
    try {
        return fs.readdirSync(dir).length === 0;
    }
    catch (_a) {
        return false;
    }
}
function main(args) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!args.from || !args.to) {
            console.error("Usage: --from <ROS-1.x root dir> --to <ROS-2.x root dir> [ --copyrealms ]");
            process.exit(1);
        }
        if (!isEmptyDir(args.to)) {
            console.error(`The destination should be an empty directory: ${args.to}`);
            process.exit(1);
        }
        const adminJsonPath = path.join(args.from, "__admin.json");
        const outputs = {
            admin: path.join(args.to, "realms", "__admin.realm"),
            password: path.join(args.to, "realms", "__password.realm"),
        };
        console.log(`will import from ${adminJsonPath}`);
        console.log(`will import to ${outputs.admin}`);
        console.log(`will import to ${outputs.password}`);
        function copyUserRealm(realmFile) {
            return __awaiter(this, void 0, void 0, function* () {
                const srcUserData = path.join(args.from, "0", "user_data");
                const dstUserData = path.join(args.to, "sync", "user_data");
                const src = virtPath_1.mapVirtToRealmPath(srcUserData, realmFile.path);
                const dst = virtPath_1.mapVirtToRealmPath(dstUserData, realmFile.path);
                const dstParent = path.dirname(dst);
                yield fs.ensureDir(dstParent);
                if (!fs.existsSync(src)) {
                    console.error(`will not copy user realm ${src}: does not exist`);
                    return;
                }
                yield fs.copy(src, dst);
                console.log(`copied user realm ${src} -> ${dst}`);
            });
        }
        const userRealmCallback = args.copyrealms ? copyUserRealm : null;
        const counts = yield importAdminJson(adminJsonPath, outputs, userRealmCallback);
        yield fs.ensureFile(path.join(args.to, "sync", "migration", "completed_0"));
        console.log(`imported users: ${counts.users}, realms: ${counts.realms}, permissions: ${counts.permissions}`);
        process.exit(0);
    });
}
const args = minimist(process.argv.slice(2));
main(args);
//# sourceMappingURL=to2.js.map