"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const Realm = require("realm");
const _ = require("lodash");
const faker = require("faker");
const path = require("path");
process.on('unhandledRejection', (reason, p) => {
    console.log('Unhandled Rejection at: Promise', p, 'reason:', reason);
});
const TickerSchema = {
    name: 'Ticker',
    primaryKey: 'tickerSymbol',
    properties: {
        'tickerSymbol': { type: 'string', optional: false, default: '' },
        'price': { type: 'float', optional: false, default: 0 },
        'companyName': { type: 'string', optional: false, default: '' }
    }
};
let server;
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        server = new __1.BasicServer();
        yield server.start({
            dataPath: path.resolve('./data'),
        });
        const authService = server.getService('auth');
        const authServerUrl = `http://${server.address}`;
        let user;
        try {
            user = yield Realm.Sync.User.login(authServerUrl, 'max', 'ilovesushi');
        }
        catch (err) {
            user = yield Realm.Sync.User.register(authServerUrl, 'max', 'ilovesushi');
        }
        user.logout();
        yield authService.createOrUpdateUser('max', 'password', true);
        user = yield Realm.Sync.User.login(authServerUrl, 'max', 'ilovesushi');
        const adminToken = __1.generateAdminToken(server.privateKey);
        const adminTokenUser = Realm.Sync.User.adminUser(adminToken, authServerUrl);
        Realm.Sync.addListener('realm://localhost:9080', adminTokenUser, '.*', 'change', (e) => {
            console.log(e);
        });
        const TickerSymbolArray = ['RLM', 'APPL', 'MRK', 'MSFT', 'FB'];
        let index = 1;
        setInterval(() => {
            let realm = new Realm({
                sync: {
                    user: adminTokenUser,
                    url: `realm://localhost:9080/${index}/tickers`
                },
                schema: [TickerSchema]
            });
            realm.write(() => {
                realm.create('Ticker', {
                    tickerSymbol: _.sample(TickerSymbolArray),
                    price: _.random(0, 100),
                    companyName: faker.company.companyName()
                }, true);
            });
            realm.close();
        }, 2000);
    });
}
main();
//# sourceMappingURL=permission-smoke-app.js.map