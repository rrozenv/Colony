"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("../decorators");
const Logger_1 = require("../shared/Logger");
const Server_1 = require("../Server");
const errors = require("../errors");
const realms_1 = require("../realms");
const util_1 = require("../shared/util");
const URI = require("urijs");
const superagent = require("superagent");
let RealmDirectoryService = class RealmDirectoryService {
    constructor() {
        this.logger = new Logger_1.Mute();
    }
    setLogger(l) {
        this.logger = l;
    }
    findByPath(realmPath, req) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!req || !req.authToken) {
                throw new errors.realm.AccessDenied();
            }
            const token = req.authToken;
            realmPath = util_1.validateRealmPath(realmPath, token);
            const owner = this.adminRealm.objectForPrimaryKey('User', token.identity);
            const realmFile = yield this.findOrCreateRealmFile(realmPath, owner);
            return {
                path: realmFile.path,
                syncLabel: realmFile.syncLabel
            };
        });
    }
    remove(realmPath, req) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = req.authToken;
            if (!token) {
                throw new errors.realm.AccessDenied();
            }
            realmPath = util_1.validateRealmPath(realmPath, token);
            const foundRevocation = this.tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', token.encodedData());
            if (foundRevocation) {
                throw new errors.realm.AccessDenied();
            }
            let accessToDeleteRealm = token.isAdmin || token.identity === '__admin';
            if (!accessToDeleteRealm) {
                throw new errors.realm.AccessDenied();
            }
            const adminRealm = this.adminRealm;
            const realmFile = adminRealm.objectForPrimaryKey("RealmFile", realmPath);
            if (!realmFile) {
                throw new errors.realm.RealmNotFound();
            }
            const syncServerDeleteRealmUrl = yield this.getSyncServerDeleteRealmUrl(realmPath, realmFile.syncLabel);
            try {
                const response = yield superagent.delete(syncServerDeleteRealmUrl).set({
                    'Authorization': 'Realm-Access-Token version=1 token="' + this.adminToken + '"'
                });
            }
            catch (err) {
                if (err.status !== 404) {
                    this.logger.error(`Could not delete realm from backend sync worker: ${err.stack}`);
                }
            }
            adminRealm.write(() => {
                const realmFile = adminRealm.objectForPrimaryKey("RealmFile", realmPath);
                if (realmFile) {
                    adminRealm.delete(realmFile.permissions);
                    adminRealm.delete(realmFile);
                }
            });
            return {};
        });
    }
    getSyncServerDeleteRealmUrl(realmPath, syncLabel) {
        return __awaiter(this, void 0, void 0, function* () {
            const syncServerHandle = yield this.discovery.find('sync', ['master', syncLabel]);
            if (!syncServerHandle) {
                throw new errors.realm.ServiceUnavailable();
            }
            return new URI(`http://${syncServerHandle.address}:${syncServerHandle.port}`)
                .segment("/api/realm")
                .segment(realmPath)
                .toString();
        });
    }
    start(server) {
        return __awaiter(this, void 0, void 0, function* () {
            this.discovery = server.discovery;
            this.adminToken = server.adminToken;
            this.adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
            this.tokenRevocationRealm = yield server.realmFactory.open(realms_1.TokenRevocationRealm);
            for (const definition of [realms_1.AdminRealm, realms_1.TokenRevocationRealm]) {
                const realmFile = this.adminRealm.objectForPrimaryKey('RealmFile', definition.remotePath);
                if (!realmFile) {
                    yield this.findOrCreateRealmFile(definition.remotePath, null, definition.syncLabel);
                }
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tokenRevocationRealm) {
                this.tokenRevocationRealm.close();
                delete this.tokenRevocationRealm;
            }
            if (this.adminRealm) {
                this.adminRealm.close();
                delete this.adminRealm;
            }
        });
    }
    findSyncLabel() {
        return __awaiter(this, void 0, void 0, function* () {
            const sync = yield this.discovery.find('sync', ["master"]);
            if (sync) {
                return sync.tags.filter((t) => {
                    return t !== "master" && t !== "slave";
                })[0] || "default";
            }
            else {
                throw new errors.realm.ServiceUnavailable();
            }
        });
    }
    findOrCreateRealmFile(realmPath, owner, syncLabel) {
        return __awaiter(this, void 0, void 0, function* () {
            let realmFile;
            if (!syncLabel) {
                syncLabel = yield this.findSyncLabel();
            }
            this.adminRealm.write(() => {
                realmFile = this.adminRealm.objectForPrimaryKey("RealmFile", realmPath);
                if (!realmFile) {
                    realmFile = this.adminRealm.create('RealmFile', {
                        owner,
                        path: realmPath,
                        createdAt: new Date(),
                        syncLabel,
                    });
                    const uri = new URI(realmPath);
                    const segments = uri.segment();
                    const userNamespace = segments[0];
                    const realmName = segments[segments.length - 1];
                    if (owner && !owner.isAdmin) {
                        if (userNamespace === owner.userId) {
                            this.adminRealm.create('Permission', {
                                realmFile,
                                mayManage: true,
                                mayRead: true,
                                mayWrite: true,
                                updatedAt: new Date(),
                                user: owner,
                            });
                        }
                    }
                    else {
                        const owner = this.adminRealm.objectForPrimaryKey('User', userNamespace);
                        if (owner) {
                            realmFile.owner = owner;
                            if (realmName === "__permission") {
                                this.adminRealm.create('Permission', {
                                    realmFile,
                                    mayManage: false,
                                    mayRead: true,
                                    mayWrite: true,
                                    updatedAt: new Date(),
                                    user: owner,
                                });
                            }
                            else if (realmName === "__perm") {
                                this.adminRealm.create('Permission', {
                                    realmFile,
                                    mayManage: false,
                                    mayRead: true,
                                    mayWrite: false,
                                    updatedAt: new Date(),
                                    user: owner,
                                });
                            }
                        }
                    }
                }
            });
            return realmFile;
        });
    }
};
__decorate([
    decorators_1.Unmute(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Logger_1.Logger]),
    __metadata("design:returntype", void 0)
], RealmDirectoryService.prototype, "setLogger", null);
__decorate([
    decorators_1.Get('/files/:realmPath'),
    __param(0, decorators_1.Params('realmPath')),
    __param(1, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], RealmDirectoryService.prototype, "findByPath", null);
__decorate([
    decorators_1.Delete('/files/:realmPath'),
    __param(0, decorators_1.Params('realmPath')),
    __param(1, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], RealmDirectoryService.prototype, "remove", null);
__decorate([
    decorators_1.Start(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Server_1.Server]),
    __metadata("design:returntype", Promise)
], RealmDirectoryService.prototype, "start", null);
__decorate([
    decorators_1.Stop(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], RealmDirectoryService.prototype, "stop", null);
RealmDirectoryService = __decorate([
    decorators_1.BaseRoute('/realms'),
    decorators_1.ServiceName('realms')
], RealmDirectoryService);
exports.RealmDirectoryService = RealmDirectoryService;
//# sourceMappingURL=RealmDirectoryService.js.map