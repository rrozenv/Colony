"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("../decorators");
const Server_1 = require("../Server");
const Token_1 = require("../shared/Token");
const realms_1 = require("../realms");
const errors = require("../errors");
const path = require("path");
const moment = require("moment");
const URI = require("urijs");
const _ = require("lodash");
const events_1 = require("events");
function extractPermission(p) {
    return {
        user: p.user ? {
            userId: p.user.userId,
        } : null,
        realmFile: p.realmFile ? {
            path: p.realmFile.path,
            owner: p.realmFile.owner ? { userId: p.realmFile.owner.userId } : null,
        } : null,
        mayRead: p.mayRead,
        mayWrite: p.mayWrite,
        mayManage: p.mayManage,
        updatedAt: p.updatedAt,
    };
}
let PermissionService = PermissionService_1 = class PermissionService extends events_1.EventEmitter {
    start(server) {
        return __awaiter(this, void 0, void 0, function* () {
            this.server = server;
            this.dataPath = path.resolve(server.dataPath, "permissions");
            this.privateKey = server.privateKey;
            this.publicKey = server.publicKey;
            this.logger = server.logger;
            this.adminTokenUser = Realm.Sync.User.adminUser(Token_1.generateAdminToken(this.privateKey), `http://${server.address}`);
            this.adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
            this.legacyWildcardPermissionRealm = yield server.realmFactory.open(realms_1.LegacyWildcardPermissionRealm);
            this.wildcardPermissionRealm = yield server.realmFactory.open(realms_1.WildcardPermissionRealm);
            const syncBaseUrl = `realm://${server.address}`;
            const authUrl = `http://${server.address}`;
            const adminUser = Realm.Sync.User.adminUser(Token_1.generateAdminToken(this.privateKey), authUrl);
            this.handleAdminChangeCallback = this.handleAdminRealmChange.bind(this);
            Realm.Sync.addListener(syncBaseUrl, adminUser, PermissionService_1.ADMIN_REALM_REGEX, 'change', this.handleAdminChangeCallback);
            this.handleManagementChangeCallback = this.handleManagementRealmChange.bind(this);
            Realm.Sync.addListener(syncBaseUrl, adminUser, PermissionService_1.MANAGEMENT_REALM_REGEX, 'change', this.handleManagementChangeCallback);
            yield this.grantReadOnlyAccessToWildcardPermissionRealm();
            yield this.grantReadWriteOnLegacyUserPermissionRealms();
        });
    }
    grantReadWriteOnLegacyUserPermissionRealms() {
        return __awaiter(this, void 0, void 0, function* () {
            this.adminRealm.write(() => {
                const wrongPerms = this.adminRealm.objects('Permission').filtered('user != null AND mayWrite != true AND realmFile.path ENDSWITH "/__permission"');
                for (const p of wrongPerms) {
                    if (p.realmFile.path !== `/${p.user.userId}/__permission`) {
                        continue;
                    }
                    this.logger.debug(`granting read-write on ${p.realmFile.path} to ${p.user.userId}`);
                    p.mayRead = true;
                    p.mayWrite = true;
                }
            });
        });
    }
    stop() {
        if (this.handleManagementChangeCallback) {
            Realm.Sync.removeListener(PermissionService_1.MANAGEMENT_REALM_REGEX, 'change', this.handleManagementChangeCallback);
            delete this.handleManagementChangeCallback;
        }
        if (this.handleAdminChangeCallback) {
            Realm.Sync.removeListener(PermissionService_1.ADMIN_REALM_REGEX, 'change', this.handleAdminChangeCallback);
            delete this.handleAdminChangeCallback;
        }
        if (this.adminRealm) {
            this.adminRealm.close();
            delete this.adminRealm;
        }
        if (this.wildcardPermissionRealm) {
            this.wildcardPermissionRealm.close();
            delete this.wildcardPermissionRealm;
        }
        if (this.legacyWildcardPermissionRealm) {
            this.legacyWildcardPermissionRealm.close();
            delete this.legacyWildcardPermissionRealm;
        }
    }
    onDemand(accessToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!accessToken) {
                throw new errors.JSONError({
                    title: "X-Realm-Access-Token header is not valid",
                    status: 400,
                });
            }
            const token = Token_1.Token.parse(accessToken, this.publicKey);
            const userId = token.identity;
            const permissionsInAdminRealm = this.adminRealm.objects('Permission')
                .filtered('user.userId = $0 || realmFile.owner.userId = $0', userId);
            for (const legacy of [true, false]) {
                const userSpecificRealm = yield this.getUserSpecificPermissionRealm(userId, legacy);
                let didUpdateAnyPermission = false;
                userSpecificRealm.beginTransaction();
                for (const permissionFromAdminRealm of permissionsInAdminRealm.snapshot().filter(p => p.user)) {
                    if (this.reflectPermissionIn(permissionFromAdminRealm, userSpecificRealm, legacy)) {
                        didUpdateAnyPermission = true;
                    }
                }
                if (didUpdateAnyPermission) {
                    userSpecificRealm.commitTransaction();
                }
                else {
                    userSpecificRealm.cancelTransaction();
                }
                userSpecificRealm.close();
            }
            return {
                userId: userId,
                affectedPermissionsCount: permissionsInAdminRealm.length
            };
        });
    }
    unreflectPermissionIn(perm, mirror, legacy = false) {
        if (!mirror.isInTransaction) {
            throw new Error("user permission reflection attepmted outside of transaction");
        }
        let reflection;
        const pk = (perm.user ? perm.user.userId : '*') + '-' + perm.realmFile.path;
        if (legacy) {
            if (perm.user) {
                reflection = mirror.objects('Permission')
                    .filtered('userId == $0 && path == $1', perm.user.userId, perm.realmFile.path)[0];
            }
            else {
                reflection = mirror.objects('Permission')
                    .filtered('path == $0', perm.realmFile.path)[0];
            }
        }
        else {
            reflection = mirror.objectForPrimaryKey("Permission", pk);
        }
        if (!reflection) {
            return false;
        }
        mirror.delete(reflection);
        return true;
    }
    reflectPermissionIn(perm, mirror, legacy = false) {
        if (!mirror.isInTransaction) {
            throw new Error("user permission reflection attepmted outside of transaction");
        }
        let reflection;
        const update = {};
        const pk = (perm.user ? perm.user.userId : '*') + '-' + perm.realmFile.path;
        if (legacy) {
            if (perm.user) {
                reflection = mirror.objects('Permission')
                    .filtered('userId == $0 && path == $1', perm.user.userId, perm.realmFile.path)[0];
            }
            else {
                reflection = mirror.objects('Permission')
                    .filtered('path == $0', perm.realmFile.path)[0];
            }
        }
        else {
            reflection = mirror.objectForPrimaryKey("Permission", pk);
            update.userPath = pk;
        }
        if (reflection) {
            for (const key of ['mayRead', 'mayWrite', 'mayManage']) {
                if (reflection[key] !== perm[key]) {
                    update[key] = perm[key];
                }
            }
        }
        else {
            Object.assign(update, {
                path: perm.realmFile.path,
                mayRead: perm.mayRead,
                mayWrite: perm.mayWrite,
                mayManage: perm.mayManage,
                updatedAt: perm.updatedAt,
            });
        }
        update.userId = perm.user ? perm.user.userId : '*';
        if (Object.keys(update).length === 0) {
            return false;
        }
        if (legacy) {
            if (reflection) {
                Object.assign(reflection, update);
            }
            else {
                mirror.create("Permission", update);
            }
        }
        else {
            mirror.create("Permission", update, true);
        }
        return true;
    }
    getUserByUserId(userId) {
        return this.adminRealm.objectForPrimaryKey('User', userId);
    }
    getUserByProviderId(providerId, provider) {
        const accounts = this.adminRealm.objects('Account').filtered(`provider = $0 AND providerId = $1`, provider, providerId);
        if (accounts.length > 0) {
            return accounts[0].user[0];
        }
    }
    getUserIdsWithMetadata(key, value) {
        let userIds = new Set();
        if (key === 'email') {
            const user = this.getUserByProviderId(value, 'password');
            if (user) {
                userIds.add(user.userId);
            }
        }
        let metadata = this.adminRealm.objects('UserMetadataRow');
        if (key && value) {
            metadata = metadata.filtered("key = $0 AND value = $1", key, value);
        }
        metadata.forEach(meta => userIds.add(meta.user[0].userId));
        return Array.from(userIds);
    }
    getUsersByUserIds(userIds) {
        const query = userIds.map((id, index) => {
            return `userId = $${index}`;
        }).join(" || ");
        return this.adminRealm.objects("User").filtered(query, ...userIds);
    }
    getManagementRealmForUserId(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const realmDefinition = realms_1.CreateUserManagementRealmDefinition(userId);
            return this.server.realmFactory.open(realmDefinition);
        });
    }
    grantReadOnlyAccessToWildcardPermissionRealm() {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            const exposeAsReadOnly = function (realmPath) {
                const wildcardRealmFile = self.adminRealm.objectForPrimaryKey('RealmFile', realmPath);
                if (!wildcardRealmFile) {
                    self.logger.error('Could not find the WildcardPermission RealmFile in Admin Realm!');
                }
                else {
                    let wildcardPerm = wildcardRealmFile.permissions.filtered('user == null')[0];
                    if (!wildcardPerm) {
                        self.adminRealm.write(() => {
                            wildcardPerm = self.adminRealm.create('Permission', {
                                user: null,
                                realmFile: wildcardRealmFile,
                                updatedAt: new Date(),
                                mayRead: true,
                                mayWrite: false,
                                mayManage: false,
                            });
                        });
                    }
                }
            };
            yield exposeAsReadOnly(realms_1.LegacyWildcardPermissionRealm.remotePath);
            yield exposeAsReadOnly(realms_1.WildcardPermissionRealm.remotePath);
        });
    }
    applyPermissionChangeInAdminRealm(realmFilePath, userId, mayRead, mayWrite, mayManage) {
        return __awaiter(this, void 0, void 0, function* () {
            const realmFile = this.adminRealm.objectForPrimaryKey("RealmFile", realmFilePath);
            if (!realmFile) {
                throw new errors.realm.InvalidParameters({ name: 'realmFilePath', reason: `The provided realmFilePath (${realmFilePath}) does not exist.` });
            }
            let permission;
            let user;
            let shouldDelete = (mayRead === false && mayWrite === false && mayManage === false);
            this.adminRealm.write(() => {
                if (userId) {
                    user = this.getUserByUserId(userId);
                    permission = realmFile.permissions.filtered('user.userId = $0', userId)[0];
                }
                else {
                    permission = realmFile.permissions.filtered('user == null')[0];
                }
                if (!permission && !shouldDelete) {
                    permission = this.adminRealm.create('Permission', {
                        user: user,
                        realmFile: realmFile,
                        updatedAt: new Date(),
                        mayRead: mayRead || false,
                        mayWrite: mayWrite || false,
                        mayManage: mayManage || false
                    });
                }
                else if (permission && shouldDelete) {
                    this.adminRealm.delete(permission);
                }
                else if (permission && !shouldDelete) {
                    if (mayRead != null) {
                        permission.mayRead = mayRead;
                    }
                    if (mayWrite != null) {
                        permission.mayWrite = mayWrite;
                    }
                    if (mayManage != null) {
                        permission.mayManage = mayManage;
                    }
                    permission.updatedAt = new Date();
                }
            });
        });
    }
    getUserSpecificPermissionRealm(userId, legacy = false) {
        const realmDefinition = legacy ? realms_1.CreateLegacyUserPermissionRealmDefinition(userId) : realms_1.CreateUserPermissionRealmDefinition(userId);
        return this.server.realmFactory.open(realmDefinition);
    }
    handleAdminRealmChange(changeEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            const permissionChanges = changeEvent.changes['Permission'];
            if (permissionChanges) {
                const whereToReflect = function (permission) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const mirrors = [];
                        const legacyMirrors = [];
                        if (permission.user) {
                            const granteeId = permission.user.userId;
                            const grantorId = permission.realmFile.owner.userId;
                            mirrors.push(yield self.getUserSpecificPermissionRealm(granteeId));
                            legacyMirrors.push(yield self.getUserSpecificPermissionRealm(granteeId, true));
                            if (granteeId !== grantorId) {
                                mirrors.push(yield self.getUserSpecificPermissionRealm(grantorId));
                                legacyMirrors.push(yield self.getUserSpecificPermissionRealm(grantorId, true));
                            }
                        }
                        else {
                            self.wildcardPermissionRealm.open();
                            self.legacyWildcardPermissionRealm.open();
                            mirrors.push(self.wildcardPermissionRealm);
                            legacyMirrors.push(self.legacyWildcardPermissionRealm);
                        }
                        return [mirrors, legacyMirrors];
                    });
                };
                const writeInAppropriateMirrors = function (permission, operation) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const [mirrors, legacyMirrors] = yield whereToReflect(permission);
                        try {
                            for (const mirror of mirrors) {
                                mirror.write(() => {
                                    operation(mirror, false);
                                });
                            }
                            for (const mirror of legacyMirrors) {
                                mirror.write(() => {
                                    operation(mirror, true);
                                });
                            }
                        }
                        finally {
                            for (const mirror of [...mirrors, ...legacyMirrors]) {
                                mirror.close();
                            }
                        }
                    });
                };
                self.emit('handlePermissionReflection', changeEvent);
                const collection = changeEvent.realm.objects('Permission');
                const insertedPermissions = permissionChanges.insertions.map(i => extractPermission(collection[i]));
                const modifiedPermissions = permissionChanges.modifications.map(i => extractPermission(collection[i]));
                let deletedPermissions = [];
                if (permissionChanges.deletions.length > 0) {
                    const oldCollection = changeEvent.oldRealm.objects('Permission');
                    deletedPermissions = permissionChanges.deletions.map(i => extractPermission(oldCollection[i]));
                }
                for (const permission of [...insertedPermissions, ...modifiedPermissions]) {
                    yield writeInAppropriateMirrors(permission, (mirror, legacy = false) => {
                        self.reflectPermissionIn(permission, mirror, legacy);
                    });
                }
                for (const permission of deletedPermissions) {
                    yield writeInAppropriateMirrors(permission, (mirror, legacy = false) => {
                        self.unreflectPermissionIn(permission, mirror, legacy);
                    });
                }
            }
        });
    }
    handleManagementRealmChange(changeEvent) {
        return __awaiter(this, void 0, void 0, function* () {
            const matches = changeEvent.path.match(PermissionService_1.MANAGEMENT_REALM_REGEX);
            if (!matches) {
                return;
            }
            ;
            let userId = matches[1];
            if (userId == '__auth') {
                userId = '__admin';
            }
            const owner = this.getUserByUserId(userId);
            const realm = changeEvent.realm;
            this.logger.debug(`A management realm with path ${changeEvent.path} has changes with userId: ${userId}`);
            if (realm.schema.findIndex(objSchema => { return objSchema.name === 'PermissionOffer'; }) !== -1) {
                let unprocessedPermissionOfferObjects = realm.objects("PermissionOffer").filtered('statusCode == null');
                for (let p of unprocessedPermissionOfferObjects.snapshot()) {
                    this.handlePermissionOfferObject(p, owner, realm);
                }
            }
            if (realm.schema.findIndex(objSchema => { return objSchema.name === 'PermissionOfferResponse'; }) !== -1) {
                let unprocessedPermissionOfferResponseObjects = realm.objects("PermissionOfferResponse").filtered('statusCode == null');
                for (let p of unprocessedPermissionOfferResponseObjects.snapshot()) {
                    yield this.handlePermissionOfferResponseObject(p, owner, realm);
                }
            }
            if (realm.schema.findIndex(objSchema => { return objSchema.name === 'PermissionChange'; }) !== -1) {
                let unprocessedPermissionChangeObjects = realm.objects("PermissionChange").filtered('statusCode == null');
                for (let p of unprocessedPermissionChangeObjects.snapshot()) {
                    this.handlePermissionChangeObject(p, owner, realm);
                }
            }
        });
    }
    handlePermissionOfferObject(permissionOffer, owner, realm) {
        try {
            if (!owner) {
                throw new errors.realm.InvalidParameters({
                    name: 'realmUrl',
                    reason: 'The user specified in the realmUrl does not exist.'
                });
            }
            const realmPath = new URI(permissionOffer.realmUrl).path().replace('~', owner.userId);
            this.validateUserIdCanChangePermissionsForPath(owner, realmPath);
            if (permissionOffer.expiresAt && moment(permissionOffer.expiresAt).isBefore(moment.now())) {
                throw new errors.realm.ExpiredPermissionOffer();
            }
            realm.write(() => {
                permissionOffer.realmUrl = realmPath;
                permissionOffer.token = `${owner.userId}:${permissionOffer.id}`;
                permissionOffer.statusCode = 0;
            });
        }
        catch (err) {
            const problem = err;
            this.logger.error(problem.toString());
            realm.write(() => {
                permissionOffer.statusMessage = problem.title;
                permissionOffer.statusCode = problem.code;
            });
        }
    }
    handlePermissionOfferResponseObject(permissionOfferResponse, owner, realm) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const tokenComponents = permissionOfferResponse.token.split(':');
                if (tokenComponents.length < 2 || tokenComponents[0].length === 0) {
                    throw new errors.realm.InvalidParameters('token');
                }
                const offeringUserId = tokenComponents[0];
                let offeringRealm = yield this.getManagementRealmForUserId(offeringUserId);
                try {
                    const permissionOffers = offeringRealm.objects("PermissionOffer").filtered('token = $0', permissionOfferResponse.token);
                    if (permissionOffers.length === 0) {
                        throw new errors.realm.InvalidParameters('token');
                    }
                    if (permissionOffers.length > 1) {
                        throw new errors.realm.AmbiguousPermissionOfferToken({
                            detail: `Unexpected count of permission offers (=${permissionOffers.length})`
                                + ` matching the token '${permissionOfferResponse.token}' of the permission request!`,
                        });
                    }
                    const permissionOffer = permissionOffers[0];
                    if (permissionOffer.expiresAt && moment(permissionOffer.expiresAt).isBefore(moment.now())) {
                        throw new errors.realm.ExpiredPermissionOffer();
                    }
                    const realmPath = new URI(permissionOffer.realmUrl).path();
                    let mayRead = permissionOffer.mayRead || null;
                    let mayWrite = permissionOffer.mayWrite || null;
                    let mayManage = permissionOffer.mayManage || null;
                    this.applyPermissionChangeInAdminRealm(realmPath, owner.userId, mayRead, mayWrite, mayManage);
                    realm.write(() => {
                        permissionOfferResponse.realmUrl = realmPath;
                        permissionOfferResponse.statusCode = 0;
                    });
                }
                finally {
                    offeringRealm.close();
                }
            }
            catch (err) {
                const problem = err;
                this.logger.error(problem.toString());
                realm.write(() => {
                    permissionOfferResponse.statusMessage = problem.title;
                    permissionOfferResponse.statusCode = problem.code;
                });
            }
        });
    }
    handlePermissionChangeObject(permissionChange, owner, realm) {
        try {
            if (!owner) {
                throw new errors.realm.InvalidParameters({
                    name: 'realmUrl',
                    reason: 'The user specified in the realmUrl does not exist.'
                });
            }
            const realmPath = new URI(permissionChange.realmUrl).path().replace('~', owner.userId);
            if (permissionChange.userId === '*' && permissionChange.realmUrl === '*') {
                this.handleWildcardRealmUrlForAllUsers(permissionChange, owner);
            }
            else if (permissionChange.realmUrl === '*') {
                this.handleWildcardRealmUrlForUser(permissionChange, owner);
            }
            else if (permissionChange.userId === '*') {
                this.validateUserIdCanChangePermissionsForPath(owner, realmPath);
                this.handleWildcardUserIdUrl(permissionChange, realmPath);
            }
            else {
                this.validateUserIdCanChangePermissionsForPath(owner, realmPath);
                let users;
                if (permissionChange.metadataKey) {
                    const userIds = this.getUserIdsWithMetadata(permissionChange.metadataKey, permissionChange.metadataValue);
                    if (userIds.length === 0) {
                        throw new errors.realm.InvalidParameters({ name: 'metadataValue', reason: `The provided metadata value (${permissionChange.metadataValue}) matched no users.` });
                    }
                    this.logger.debug(`Apply permission change by metadata query 
                        (${permissionChange.metadataKey}=${permissionChange.metadataValue}) 
                        matching the userIds ${userIds}`);
                    users = this.getUsersByUserIds(userIds);
                }
                else {
                    this.logger.debug(`Apply permission change for user ${permissionChange.userId}`);
                    users = this.getUsersByUserIds([permissionChange.userId]);
                }
                const realmFiles = this.adminRealm.objects(realms_1.RealmFile.schema.name).filtered('path = $0', realmPath);
                this.setPermissionChangesInAdminRealm(users, realmFiles, permissionChange.mayWrite, permissionChange.mayRead, permissionChange.mayManage);
            }
            realm.write(() => {
                permissionChange.statusCode = 0;
                permissionChange.statusMessage = `Successfully applied PermissionChange for ${realmPath}`;
            });
        }
        catch (err) {
            const problem = err;
            this.logger.error(problem.toString());
            realm.write(() => {
                permissionChange.statusMessage = problem.title;
                permissionChange.statusCode = problem.code;
            });
        }
    }
    validateUserIdCanChangePermissionsForPath(owner, path) {
        if (_.includes(path, '__management')) {
            throw new errors.realm.InvalidParameters({
                name: 'realmUrl',
                reason: 'The realmUrl cannot be of a management realm'
            });
        }
        if (_.includes(path, '__permission')) {
            throw new errors.realm.InvalidParameters({
                name: 'realmUrl',
                reason: 'The realmUrl cannot be of a permission realm'
            });
        }
        if (_.includes(path, '__perm')) {
            throw new errors.realm.InvalidParameters({
                name: 'realmUrl',
                reason: 'The realmUrl cannot be of a permission realm'
            });
        }
        const realmFile = this.adminRealm.objectForPrimaryKey(realms_1.RealmFile.schema.name, path);
        if (!realmFile) {
            throw new errors.realm.InvalidParameters({
                name: 'realmUrl',
                reason: 'The realmUrl does not exist'
            });
        }
        const permissions = realmFile.permissions.filtered('(user = $0 OR user == null) AND mayManage = true', owner);
        if (!owner.isAdmin && permissions.length === 0) {
            throw new errors.realm.AccessDenied();
        }
    }
    handleWildcardUserIdUrl(permissionChange, path) {
        this.applyPermissionChangeInAdminRealm(path, null, permissionChange.mayRead, permissionChange.mayWrite, permissionChange.mayManage);
    }
    handleWildcardRealmUrlForUser(permissionChange, owner) {
        const ownedRealmFiles = this.adminRealm.objects(realms_1.RealmFile.schema.name)
            .filtered('owner = $0', owner);
        const users = this.getUsersByUserIds([permissionChange.userId]);
        this.setPermissionChangesInAdminRealm(users, ownedRealmFiles, permissionChange.mayWrite, permissionChange.mayRead, permissionChange.mayManage);
    }
    handleWildcardRealmUrlForAllUsers(permissionChange, owner) {
        const ownedRealmFiles = this.adminRealm.objects(realms_1.RealmFile.schema.name)
            .filtered('owner = $0', owner);
        for (const realmFile of ownedRealmFiles) {
            this.applyPermissionChangeInAdminRealm(realmFile.path, null, permissionChange.mayRead, permissionChange.mayWrite, permissionChange.mayManage);
        }
    }
    setPermissionChangesInAdminRealm(users, realmFiles, mayWrite, mayRead, mayManage, permissionChange) {
        for (let file of realmFiles) {
            for (let user of users) {
                this.applyPermissionChangeInAdminRealm(file.path, user.userId, mayRead, mayWrite, mayManage);
            }
        }
    }
};
PermissionService.MANAGEMENT_REALM_REGEX = '^/([^/]+)/__management$';
PermissionService.ADMIN_REALM_REGEX = `/__admin`;
__decorate([
    decorators_1.Start(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Server_1.Server]),
    __metadata("design:returntype", Promise)
], PermissionService.prototype, "start", null);
__decorate([
    decorators_1.Stop(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], PermissionService.prototype, "stop", null);
__decorate([
    decorators_1.Get('/ondemand'),
    __param(0, decorators_1.Headers('X-Realm-Access-Token')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PermissionService.prototype, "onDemand", null);
PermissionService = PermissionService_1 = __decorate([
    decorators_1.BaseRoute('/permissions'),
    decorators_1.ServiceName('permissions')
], PermissionService);
exports.PermissionService = PermissionService;
var PermissionService_1;
//# sourceMappingURL=PermissionsService.js.map