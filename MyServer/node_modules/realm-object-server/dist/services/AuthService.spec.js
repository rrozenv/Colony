"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const sinon = require("sinon");
const faker = require("faker");
const TestServer_1 = require("../TestServer");
const Token_1 = require("../shared/Token");
const auth = require("../auth");
const errors = require("../errors");
describe('AuthService', () => {
    let server;
    let service;
    let provider;
    let adminAuthToken;
    before(() => __awaiter(this, void 0, void 0, function* () {
        server = new TestServer_1.TestServer();
        provider = new auth.DebugAuthProvider();
        yield server.start({
            authProviders: [provider]
        });
        service = server.getService('auth');
        adminAuthToken = Token_1.Token.parse(server.adminToken, server.publicKey);
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown();
    }));
    describe("createOrUpdateUser", () => {
        describe("without a provider ID and provider", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                const err = yield chai_1.assert.isRejected(service.createOrUpdateUser(undefined, undefined, false), errors.realm.MissingParameters);
                chai_1.assert.includeDeepMembers(err.invalidParams, [{
                        name: "providerId",
                        reason: "Missing parameter 'providerId'!",
                    }, {
                        name: "provider",
                        reason: "Missing parameter 'provider'!",
                    }]);
            }));
        });
        describe("without a provider", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                const err = yield chai_1.assert.isRejected(service.createOrUpdateUser("some-user", undefined, false), errors.realm.MissingParameters);
                chai_1.assert.includeDeepMembers(err.invalidParams, [{
                        name: "provider",
                        reason: "Missing parameter 'provider'!",
                    }]);
            }));
        });
        describe("without a providerId", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                const err = yield chai_1.assert.isRejected(service.createOrUpdateUser(undefined, "debug", false), errors.realm.MissingParameters);
                chai_1.assert.includeDeepMembers(err.invalidParams, [{
                        name: "providerId",
                        reason: "Missing parameter 'providerId'!",
                    }]);
            }));
        });
        describe("with a userId that requires URL encoding", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                const err = yield chai_1.assert.isRejected(service.createOrUpdateUser("some-user", "debug", false, {}, "some/user"), errors.realm.InvalidParameters);
                chai_1.assert.includeDeepMembers(err.invalidParams, [{
                        name: 'userId',
                        reason: 'Realm requires the userId that does not require URI encoding.'
                    }]);
            }));
        });
        describe("when the user already exists", () => {
            let user;
            let username;
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                username = faker.internet.userName();
                user = yield service.createOrUpdateUser(username, "debug", false);
            }));
            it("without userId should not create a new user", () => __awaiter(this, void 0, void 0, function* () {
                const result = yield chai_1.assert.isFulfilled(service.createOrUpdateUser(username, "debug", false));
                chai_1.assert.isFalse(result.created);
            }));
            it("with userId should not create a new user", () => __awaiter(this, void 0, void 0, function* () {
                const result = yield chai_1.assert.isFulfilled(service.createOrUpdateUser(username, "debug", false, {}, user.userId));
                chai_1.assert.isFalse(result.created);
            }));
            it("with incorrect userId should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.createOrUpdateUser(username, "debug", false, {}, "some-other-userid"), errors.realm.InvalidParameters);
            }));
        });
        describe("when the user does not already exist", () => {
            it("without userId should create a new user", () => __awaiter(this, void 0, void 0, function* () {
                const result = yield chai_1.assert.isFulfilled(service.createOrUpdateUser(faker.internet.userName(), "debug", false));
                chai_1.assert.isTrue(result.created);
            }));
            it("with userId should create a new user with the userId", () => __awaiter(this, void 0, void 0, function* () {
                const username = faker.internet.userName();
                const result = yield chai_1.assert.isFulfilled(service.createOrUpdateUser(username, "debug", false, {}, "some-userid"));
                chai_1.assert.equal(result.userId, "some-userid");
                chai_1.assert.isTrue(result.created);
                chai_1.assert.equal(result.accounts[0].provider, "debug");
                chai_1.assert.equal(result.accounts[0].providerId, username);
            }));
        });
    });
    describe("getUserById", () => {
        describe("when the user does not exist", () => {
            it("should not return a user", () => {
                const user = service.getUserById("some-userId");
                chai_1.assert.isUndefined(user);
            });
        });
        describe("when the user exists", () => {
            let user;
            let username;
            before(() => __awaiter(this, void 0, void 0, function* () {
                username = faker.internet.userName();
                user = yield service.createOrUpdateUser(username, 'debug', false);
            }));
            it("should return the user", () => {
                const foundUser = service.getUserById(user.userId);
                chai_1.assert.isDefined(foundUser);
                chai_1.assert.equal(foundUser.userId, user.userId);
                chai_1.assert.isFalse(foundUser.isAdmin);
                chai_1.assert.equal(foundUser.accounts[0].provider, "debug");
                chai_1.assert.equal(foundUser.accounts[0].providerId, username);
            });
        });
    });
    describe("getUserByProviderId", () => {
        describe("when the user exists", () => {
            let user;
            let username;
            before(() => __awaiter(this, void 0, void 0, function* () {
                username = faker.internet.userName();
                user = yield service.createOrUpdateUser(username, 'debug', false);
            }));
            it('should be able to get a user', () => __awaiter(this, void 0, void 0, function* () {
                const fetchedUser = service.getUserByProviderId("debug", username);
                chai_1.assert.isDefined(fetchedUser);
                chai_1.assert.isDefined(fetchedUser.userId);
                chai_1.assert.isFalse(fetchedUser.isAdmin);
                chai_1.assert.equal(fetchedUser.accounts[0].provider, "debug");
                chai_1.assert.equal(fetchedUser.accounts[0].providerId, username);
            }));
        });
        describe("when the user does not exist", () => {
            it('should be able to get a user', () => __awaiter(this, void 0, void 0, function* () {
                const fetchedUser = service.getUserByProviderId("debug", "some-user");
                chai_1.assert.isUndefined(fetchedUser);
            }));
        });
    });
    describe("updateProviderData", () => {
        describe("with an existing user", () => {
            let user;
            before(() => __awaiter(this, void 0, void 0, function* () {
                const username = faker.internet.userName();
                user = yield service.createOrUpdateUser(username, 'debug', false);
            }));
            it("should call the provider's update function", () => __awaiter(this, void 0, void 0, function* () {
                const spy = sinon.spy(provider, "update");
                yield chai_1.assert.isFulfilled(service.updateProviderData("debug", user.userId, { debuggy: "mcbuggerson" }));
                sinon.assert.calledOnce(spy);
            }));
        });
        describe("without an existing user", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.updateProviderData("debug", "some-bogus-userId", {}), errors.realm.UnknownAccount);
            }));
        });
        describe("without a valid provider", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                const err = yield chai_1.assert.isRejected(service.updateProviderData("snapchat", "lololol", {}), errors.realm.InvalidParameters);
                chai_1.assert.includeDeepMembers(err.invalidParams, [{
                        name: "provider",
                        reason: "Invalid parameter 'provider'!",
                    }]);
            }));
        });
    });
    describe("deleteUser", () => {
        describe("without an authToken", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.deleteUser("some-bogus-userId", { noAuthToken: "something" }), errors.realm.AccessDenied);
            }));
        });
        describe("without an existing user", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.deleteUser("some-bogus-userId", { authToken: adminAuthToken }), errors.realm.UnknownUser);
            }));
        });
        describe("Delete a user twice", () => {
            let userId;
            before(() => __awaiter(this, void 0, void 0, function* () {
                const username = faker.internet.userName();
                const user = yield service.createOrUpdateUser(username, 'debug', false);
                userId = user.userId;
            }));
            it("should accept", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.becomes(service.deleteUser(userId, { authToken: adminAuthToken }), {});
            }));
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.deleteUser(userId, { authToken: adminAuthToken }), errors.realm.UnknownUser);
            }));
        });
    });
});
//# sourceMappingURL=AuthService.spec.js.map