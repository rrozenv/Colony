"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const superagent = require("superagent");
const URI = require("urijs");
const moment = require("moment");
const crypto = require("crypto");
const util_1 = require("../shared/util");
const decorators_1 = require("../decorators");
const Server_1 = require("../Server");
const Token_1 = require("../shared/Token");
const errors = require("../errors");
const realms_1 = require("../realms");
let AuthService = class AuthService {
    constructor(config = {}) {
        this.providers = [];
        this.refreshTokenTtl = config.refreshTokenTtl || moment.duration(10, 'years').asSeconds();
        this.accessTokenTtl = config.accessTokenTtl || moment.duration(6, 'minutes').asSeconds();
    }
    addProvider(provider) {
        this.providers.push(provider);
    }
    start(server) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger = server.logger.withContext({ service: "auth" });
            this.discovery = server.discovery;
            this.server = server;
            this.logger = server.logger;
            this.privateKey = server.privateKey;
            this.publicKey = server.publicKey;
            this.adminToken = Token_1.generateAdminToken(server.privateKey);
            this.adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
            this.tokenRevocationRealm = yield server.realmFactory.open(realms_1.TokenRevocationRealm);
            try {
                const userId = "__admin";
                let foundUser = this.adminRealm.objectForPrimaryKey('User', userId);
                if (!foundUser) {
                    foundUser = yield this.createOrUpdateUser(userId, 'realm', true, {}, userId);
                    this.logger.info(`Autocreated admin token user: ${userId}`);
                }
            }
            catch (err) {
                this.logger.error('Failed to autocreate admin token user', err);
            }
            this.pruneRevocationTokens();
            this.cleanupInterval = setInterval(this.pruneRevocationTokens.bind(this), 1000 * 60 * 60 * 24);
            for (const provider of this.providers) {
                this.logger.detail(`Starting auth provider '${provider.name}'`);
                Reflect.set(provider, "service", this);
                if (provider.start) {
                    yield provider.start();
                }
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const provider of this.providers) {
                if (provider.stop) {
                    yield provider.stop();
                }
                Reflect.set(provider, "service", undefined);
            }
            if (this.cleanupInterval) {
                clearInterval(this.cleanupInterval);
            }
            if (this.tokenRevocationRealm) {
                this.tokenRevocationRealm.close();
                delete this.tokenRevocationRealm;
            }
            if (this.adminRealm) {
                this.adminRealm.close();
                delete this.adminRealm;
            }
        });
    }
    authenticate(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const providerName = request.body.provider;
            const appId = request.body["app_id"] || 'io.realm.Auth';
            if (!providerName) {
                throw new errors.realm.MissingParameters('provider');
            }
            if (providerName === 'realm') {
                const data = request.body.data;
                if (!data) {
                    throw new errors.realm.MissingParameters('data');
                }
                let refreshToken;
                try {
                    refreshToken = Token_1.Token.parse(data, this.publicKey);
                }
                catch (err) {
                    throw new errors.realm.AccessDenied();
                }
                if (refreshToken.access.indexOf("refresh") === -1) {
                    throw new errors.realm.AccessDenied();
                }
                const foundRevocation = this.tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', refreshToken.encodedData());
                if (foundRevocation) {
                    throw new errors.realm.AccessDenied();
                }
                const path = util_1.validateRealmPath(request.body['path'], refreshToken);
                return yield this.accessToken(path, data, appId);
            }
            const provider = this.providers.find((p) => { return p.name === providerName; });
            if (!provider) {
                throw new errors.realm.InvalidParameters('provider');
            }
            const user = yield provider.authenticateOrCreateUser(request.body);
            const refreshToken = new Token_1.RefreshToken({
                appId,
                identity: user.userId,
                isAdmin: user.isAdmin,
                expires: moment().add(this.refreshTokenTtl, 'second').unix(),
            });
            return {
                refresh_token: {
                    token: refreshToken.sign(this.privateKey),
                    token_data: refreshToken.toJSON(),
                }
            };
        });
    }
    accessToken(path, data, app_id) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = Token_1.Token.parse(data, this.publicKey);
            if (!(token instanceof Token_1.RefreshToken)) {
                throw new errors.realm.InvalidCredentials();
            }
            path = path.replace('~', token.identity);
            let partialSyncPath;
            const partialIndex = path.indexOf('/__partial/');
            if (partialIndex !== -1) {
                partialSyncPath = path;
                path = path.substring(0, partialIndex);
            }
            let realmsHandle = yield this.discovery.find('realms');
            if (!realmsHandle) {
                throw new Error('Unable to contact the RealmDirectoryService with the name: "realms"');
            }
            let realmFile = this.adminRealm.objectForPrimaryKey('RealmFile', path);
            if (partialSyncPath && !realmFile) {
                yield this.findRealmByPathUrl(realmsHandle, path, data);
            }
            const response = yield this.findRealmByPathUrl(realmsHandle, (partialSyncPath || path), data);
            const syncLabel = response.body['syncLabel'];
            yield util_1.waitForDownload(this.adminRealm);
            realmFile = this.adminRealm.objectForPrimaryKey('RealmFile', path);
            if (!realmFile) {
                throw new Error(`could not find realmfile: ${path}`);
            }
            if (partialSyncPath) {
                const partialRealmFile = this.adminRealm.objectForPrimaryKey('RealmFile', partialSyncPath);
                if (!partialRealmFile) {
                    throw new Error(`could not find realmfile: ${partialSyncPath}`);
                }
            }
            let access = [];
            if (!token.isAdmin) {
                let mayRead = false;
                let mayWrite = false;
                let mayManage = false;
                const permissions = realmFile.permissions.filtered('user.userId = $0 OR user.userId = null', token.identity);
                permissions.forEach(permission => {
                    mayRead = mayRead || permission.mayRead;
                    mayWrite = mayWrite || permission.mayWrite;
                    mayManage = mayManage || permission.mayManage;
                });
                if (mayRead) {
                    access.push('download');
                }
                if (mayWrite) {
                    access.push('upload');
                }
                if (mayManage) {
                    access.push('manage');
                }
                if (access.length === 0) {
                    throw new errors.realm.AccessDenied();
                }
            }
            else {
                access = ['download', 'upload', 'manage'];
            }
            let isAskingForTildePermission = ['__permission', '__perm'].some(name => path === `/${token.identity}/${name}`);
            if (isAskingForTildePermission) {
                let permissionsHandle = yield this.discovery.find('permissions');
                if (!permissionsHandle) {
                    throw new Error('Unable to contact the PermissionsService with the name: "permissions"');
                }
                const ondemandUrl = new URI(`http://${permissionsHandle.address}:${permissionsHandle.port}/`)
                    .segment('/permissions')
                    .segment('/ondemand')
                    .toString();
                yield superagent.get(ondemandUrl)
                    .set({
                    'X-Realm-Access-Token': data
                });
            }
            const appId = app_id || "io.realm.Auth";
            const expires = moment().add(this.accessTokenTtl, 'seconds').unix();
            const accessToken = new Token_1.AccessToken({
                identity: token.identity,
                appId,
                access: access,
                path: partialSyncPath || path,
                expires: moment().add(this.accessTokenTtl, 'seconds').unix(),
                syncLabel: syncLabel,
            });
            return {
                access_token: {
                    token: accessToken.sign(this.privateKey),
                    token_data: accessToken.toJSON(),
                }
            };
        });
    }
    revokeToken(tokenData, req) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!tokenData || tokenData === "") {
                throw new errors.realm.MissingParameters('token');
            }
            const token = Token_1.Token.parse(tokenData, this.publicKey);
            this.requireAdminOrUserId(req, token.identity);
            const expires = token.expires ? new Date(token.expires * 1000) : false;
            const revoked = new Date();
            if (expires && expires > revoked) {
                this.tokenRevocationRealm.write(() => {
                    this.tokenRevocationRealm.create('TokenRevocation', {
                        expires,
                        token: token.encodedData(),
                        revoked,
                    }, true);
                });
            }
            return {};
        });
    }
    getUserById(userId, req) {
        this.requireAdminOrUserId(req, userId);
        const user = this.adminRealm.objectForPrimaryKey('User', userId);
        if (!user && req) {
            throw new errors.realm.UnknownAccount();
        }
        return user;
    }
    getUserByProviderId(provider, providerId, req) {
        if (req && !req.authToken) {
            throw new errors.realm.AccessDenied();
        }
        const decodedProviderId = URI.decode(providerId);
        const accounts = this.adminRealm.objects('Account').filtered(`provider = $0 AND providerId = $1`, provider, decodedProviderId);
        if (accounts.length > 0) {
            const user = accounts[0].user[0];
            if (user) {
                this.requireAdminOrUserId(req, user.userId);
                return user;
            }
        }
        else {
            if (req && !req.authToken.isAdmin) {
                throw new errors.realm.AccessDenied();
            }
        }
        if (req) {
            throw new errors.realm.UnknownAccount();
        }
    }
    createOrUpdateUser(providerId, provider, isAdmin, metadata = {}, userId, req) {
        return __awaiter(this, void 0, void 0, function* () {
            this.requireAdminOrUserId(req);
            const canSetAdmin = !req || (req.authToken && req.authToken.isAdmin);
            if (!providerId && !provider) {
                throw new errors.realm.MissingParameters('providerId', 'provider');
            }
            if (!provider && providerId) {
                throw new errors.realm.MissingParameters('provider');
            }
            if (provider && !providerId) {
                throw new errors.realm.MissingParameters('providerId');
            }
            if (userId) {
                const encodedUserId = encodeURIComponent(userId);
                if (userId !== encodedUserId) {
                    throw new errors.realm.InvalidParameters({
                        name: 'userId',
                        reason: 'Realm requires the userId that does not require URI encoding.'
                    });
                }
            }
            let user = this.getUserByProviderId(provider, providerId);
            if (user) {
                if (userId && userId !== user.userId) {
                    throw new errors.realm.InvalidParameters({
                        name: 'userId',
                        reason: "userId does not match the user found by provider/providerId"
                    });
                }
                else if (!userId) {
                    userId = user.userId;
                }
            }
            this.adminRealm.write(() => {
                if (!user) {
                    user = this.adminRealm.create('User', {
                        userId: userId || this.generateUniqueId(),
                        isAdmin: canSetAdmin ? (isAdmin || false) : false,
                    });
                    user.accounts.push({
                        provider: provider,
                        providerId: providerId
                    });
                    user.created = true;
                }
                else {
                    user.created = false;
                }
                if (canSetAdmin && isAdmin !== undefined) {
                    user.isAdmin = isAdmin;
                }
                this.adminRealm.delete(user.metadata);
                for (let key in metadata) {
                    user.metadata.push({
                        key: key,
                        value: metadata[key]
                    });
                }
            });
            return user;
        });
    }
    updateProviderData(providerName, userId, data, req) {
        return __awaiter(this, void 0, void 0, function* () {
            let changeUserId;
            if (req) {
                if (req.authToken) {
                    this.requireAdminOrUserId(req, req.authToken.identity);
                    changeUserId = req.authToken.identity;
                    if (userId) {
                        if (req.authToken.isAdmin) {
                            changeUserId = userId;
                        }
                        else if (req.authToken.identity !== userId) {
                            throw new errors.realm.AccessDenied();
                        }
                    }
                }
                else {
                    throw new errors.realm.AccessDenied();
                }
            }
            else {
                changeUserId = userId;
            }
            const provider = this.providers.find((p) => { return p.name === providerName; });
            if (!provider) {
                throw new errors.realm.InvalidParameters('provider');
            }
            if (!data) {
                throw new errors.realm.MissingParameters('data');
            }
            const user = this.getUserById(changeUserId);
            if (!user) {
                throw new errors.realm.UnknownAccount();
            }
            if (provider.update) {
                return provider.update(user, data);
            }
            else {
                return {};
            }
        });
    }
    deleteUser(userId, req) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`User ${userId} is requested to be deleted`);
            this.requireAdminOrUserId(req, userId);
            yield this.deleteUserWithUserId(userId);
            this.logger.debug(`User ${userId} has been deleted`);
            return {};
        });
    }
    pruneRevocationTokens() {
        const deadRevocations = this.tokenRevocationRealm.objects('TokenRevocation').filtered("expires < $0", new Date());
        if (deadRevocations.length > 0) {
            this.tokenRevocationRealm.write(() => {
                this.tokenRevocationRealm.delete(deadRevocations);
            });
        }
    }
    generateUniqueId() {
        return crypto.randomBytes(16).toString('hex');
    }
    checkNotRevoked(token) {
        const foundRevocation = this.tokenRevocationRealm.objectForPrimaryKey('TokenRevocation', token.encodedData());
        if (foundRevocation) {
            throw new errors.realm.AccessDenied();
        }
    }
    requireAdminOrUserId(req, userId) {
        if (req) {
            if (!req.authToken) {
                throw new errors.realm.AccessDenied();
            }
            this.checkNotRevoked(req.authToken);
            const isAdmin = req.authToken.isAdmin || (req.authToken.identity === '__admin');
            if (!isAdmin) {
                if (userId && userId !== req.authToken.identity) {
                    throw new errors.realm.AccessDenied();
                }
                else if (!userId) {
                    throw new errors.realm.AccessDenied();
                }
            }
        }
    }
    findRealmByPathUrl(handle, path, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const findRealmByPathUrl = new URI(`http://${handle.address}:${handle.port}/`)
                .segment('/realms')
                .segment('/files')
                .segment(encodeURIComponent(path))
                .toString();
            return yield superagent.get(findRealmByPathUrl)
                .set({
                'X-Realm-Access-Token': token
            });
        });
    }
    getSyncServerDeleteRealmUrl(realmPath, syncLabel) {
        return __awaiter(this, void 0, void 0, function* () {
            const syncServerHandle = yield this.discovery.find('sync', ['master', syncLabel]);
            if (!syncServerHandle) {
                throw new Error("Unable to locate the sync server");
            }
            return new URI(`http://${syncServerHandle.address}:${syncServerHandle.port}`)
                .segment("/api/realm")
                .segment(realmPath)
                .toString();
        });
    }
    deleteUserWithUserId(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const adminRealm = this.adminRealm;
            const user = adminRealm.objectForPrimaryKey('User', userId);
            if (!user) {
                throw new errors.realm.UnknownUser();
            }
            const realmFiles = adminRealm.objects('RealmFile')
                .filtered('owner.userId = $0', userId);
            const syncServerDeleteRealmUrls = yield Promise.all(realmFiles.map((realmFile) => {
                const path = realmFile.path;
                const syncLabel = realmFile.syncLabel;
                return this.getSyncServerDeleteRealmUrl(path, syncLabel);
            }));
            let providerNames = [];
            adminRealm.write(() => {
                const user = adminRealm.objectForPrimaryKey('User', userId);
                if (!user) {
                    throw new errors.realm.UnknownUser();
                }
                adminRealm.delete(user.metadata);
                providerNames = user.accounts.map((account) => {
                    return account.provider;
                });
                adminRealm.delete(user.accounts);
                const permissions = adminRealm.objects('Permission')
                    .filtered('user.userId = $0', userId);
                adminRealm.delete(permissions);
                const realmFiles = adminRealm.objects('RealmFile')
                    .filtered('owner.userId = $0', userId);
                adminRealm.delete(realmFiles);
                adminRealm.delete(user);
            });
            let deleteUserPromises = [];
            providerNames.forEach((providerName) => {
                const provider = this.providers.find((p) => { return p.name === providerName; });
                if (provider) {
                    deleteUserPromises.push(provider.deleteUser(userId));
                }
            });
            yield Promise.all(deleteUserPromises);
            for (let url of syncServerDeleteRealmUrls) {
                try {
                    yield superagent.delete(url).set({
                        'Authorization': 'Realm-Access-Token version=1 token="' + this.adminToken + '"'
                    });
                }
                catch (err) {
                    this.logger.error(`Deletion of a Realm on the sync server failed, url = ${url}`);
                }
            }
            const localUserDir = path.join(this.server.dataPath, "realms", userId);
            fs.remove(localUserDir, (err) => {
                if (err) {
                    this.logger.error(`Unable to remove user directory: '${localUserDir}'`);
                }
            });
        });
    }
};
__decorate([
    decorators_1.Start(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Server_1.Server]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "start", null);
__decorate([
    decorators_1.Stop(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "stop", null);
__decorate([
    decorators_1.Post('/'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "authenticate", null);
__decorate([
    decorators_1.Post("/revoke"),
    __param(0, decorators_1.Body('token')),
    __param(1, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "revokeToken", null);
__decorate([
    decorators_1.Get('/users/:user_id'),
    __param(0, decorators_1.Params('user_id')),
    __param(1, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", realms_1.User)
], AuthService.prototype, "getUserById", null);
__decorate([
    decorators_1.Get('/users/:provider/:provider_id'),
    __param(0, decorators_1.Params('provider')),
    __param(1, decorators_1.Params('provider_id')),
    __param(2, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object]),
    __metadata("design:returntype", realms_1.User)
], AuthService.prototype, "getUserByProviderId", null);
__decorate([
    decorators_1.Put('/users'),
    __param(0, decorators_1.Body('provider_id')),
    __param(1, decorators_1.Body('provider')),
    __param(2, decorators_1.Body('is_admin')),
    __param(3, decorators_1.Body('metadata')),
    __param(4, decorators_1.Body('user_id')),
    __param(5, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Boolean, Object, String, Object]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "createOrUpdateUser", null);
__decorate([
    decorators_1.Put('/:provider'),
    __param(0, decorators_1.Params('provider')),
    __param(1, decorators_1.Body('user_id')),
    __param(2, decorators_1.Body('data')),
    __param(3, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object, Object]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "updateProviderData", null);
__decorate([
    decorators_1.Delete('/user/:user_id'),
    __param(0, decorators_1.Params('user_id')),
    __param(1, decorators_1.Request()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], AuthService.prototype, "deleteUser", null);
AuthService = __decorate([
    decorators_1.BaseRoute('/auth'),
    decorators_1.ServiceName('auth'),
    __metadata("design:paramtypes", [Object])
], AuthService);
exports.AuthService = AuthService;
//# sourceMappingURL=AuthService.js.map