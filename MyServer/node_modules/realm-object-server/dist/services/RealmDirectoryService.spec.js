"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const TestServer_1 = require("../TestServer");
const Token_1 = require("../shared/Token");
describe('RealmDirectoryService Tests', function () {
    let server;
    let service;
    let adminToken;
    let adminRealm;
    let authService;
    before(() => __awaiter(this, void 0, void 0, function* () {
        server = new TestServer_1.TestServer();
        yield server.start({});
        service = server.getService('realms');
        authService = server.getService("auth");
        adminToken = Token_1.Token.parse(server.adminToken, server.publicKey);
        adminRealm = service["adminRealm"];
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown().catch((err) => { });
    }));
    describe("state after start", () => {
        it('registered the internal realms used by ROS', () => __awaiter(this, void 0, void 0, function* () {
            chai_1.assert.isDefined(adminRealm.objectForPrimaryKey('RealmFile', '/__admin'));
            chai_1.assert.isDefined(adminRealm.objectForPrimaryKey('RealmFile', '/__revocation'));
        }));
    });
    describe("findByPath()", () => {
        describe("when a token is not provided", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.findByPath("%2Fproducts", {}), "The path is invalid or current user has no access.");
            }));
        });
        describe("when the realm does not exist", () => {
            describe("and the token is an admin token", () => {
                it('creates a realm and returns it', () => __awaiter(this, void 0, void 0, function* () {
                    chai_1.assert.isUndefined(adminRealm.objectForPrimaryKey('RealmFile', '/products'));
                    const response = yield service.findByPath("%2Fproducts", { authToken: adminToken });
                    chai_1.assert.equal(response.path, '/products');
                    chai_1.assert.isDefined(response.syncLabel);
                    chai_1.assert.isDefined(adminRealm.objectForPrimaryKey('RealmFile', '/products'));
                }));
            });
            describe("and the user is not an admin", () => {
                it('creates a realm and returns it', () => __awaiter(this, void 0, void 0, function* () {
                    const user = yield authService.createOrUpdateUser("debug", "joe", false);
                    const realmPath = `/${user.userId}/myrealm`;
                    chai_1.assert.isUndefined(adminRealm.objectForPrimaryKey('RealmFile', realmPath));
                    const response = yield service.findByPath(realmPath, { authToken: {
                            identity: user.userId,
                        } });
                    chai_1.assert.equal(response.path, realmPath);
                    chai_1.assert.isDefined(response.syncLabel);
                    chai_1.assert.isDefined(adminRealm.objectForPrimaryKey('RealmFile', realmPath));
                }));
            });
            describe("and path is invalid", () => {
                for (const p of ['myrealm.realm', 'cÃ¦t', '.hello']) {
                    it(`should reject /${p} with an error`, () => __awaiter(this, void 0, void 0, function* () {
                        const user = yield authService.createOrUpdateUser("debug", "joe", false);
                        const realmPath = `/${user.userId}/${p}`;
                        yield chai_1.assert.isRejected(service.findByPath(realmPath, { authToken: {
                                identity: user.userId,
                            } }), "path is invalid");
                        chai_1.assert.isUndefined(adminRealm.objectForPrimaryKey('RealmFile', realmPath));
                    }));
                }
            });
        });
    });
    describe("remove()", () => {
        let revokedToken;
        let userToken;
        let adminToken;
        before(() => {
            revokedToken = new Token_1.RefreshToken({
                isAdmin: false,
                identity: "revoked-identity",
                appId: "some.appId.com",
            });
            service["tokenRevocationRealm"].write(() => {
                service["tokenRevocationRealm"].create("TokenRevocation", {
                    token: revokedToken.encodedData(),
                    revoked: new Date(),
                });
            });
            userToken = new Token_1.RefreshToken({
                isAdmin: false,
                identity: "user-identity",
                appId: "some.appId.com",
            });
            adminToken = new Token_1.RefreshToken({
                isAdmin: true,
                identity: "admin-identity",
                appId: "some.appId.com",
            });
        });
        describe("when a token is not provided", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.remove("/some-path", {}), "The path is invalid or current user has no access.");
            }));
        });
        describe("when a revoked token is provided", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.remove("/some-path", { authToken: revokedToken }), "The path is invalid or current user has no access.");
            }));
        });
        describe("when a regular user refresh token is provided", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.remove("/some-path", { authToken: userToken }), "The path is invalid or current user has no access.");
            }));
        });
        describe("when the realm file is not found", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(service.remove("/some-path", { authToken: adminToken }), "The Realm could not be found");
            }));
        });
        describe("when the sync worker is unavailable", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield service["findOrCreateRealmFile"]("/file-to-delete", null, "otherLabel");
                yield chai_1.assert.isRejected(service.remove("/file-to-delete", { authToken: adminToken }), "The requested service is temporarily unavailable.");
            }));
        });
        describe("when the sync worker is available", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield service["findOrCreateRealmFile"]("/file-to-delete2", null);
                yield chai_1.assert.isFulfilled(service.remove("/file-to-delete2", { authToken: adminToken }));
            }));
        });
    });
});
//# sourceMappingURL=RealmDirectoryService.spec.js.map