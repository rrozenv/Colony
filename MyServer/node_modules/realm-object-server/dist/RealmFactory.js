"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Realm = require("realm");
const superagent = require("superagent");
const path = require("path");
const URI = require("urijs");
function createRealmSchema(klass) {
    const myClass = function () { };
    myClass.prototype = Object.create(klass.prototype, {
        constructor: {
            configurable: true,
            enumerable: false,
            value: myClass,
            writable: true,
        },
    });
    Object.setPrototypeOf(myClass, klass);
    const schema = klass.schema;
    Object.defineProperty(myClass, "schema", {
        get() {
            return schema;
        },
    });
    return myClass;
}
exports.createRealmSchema = createRealmSchema;
class RealmPromise extends Promise {
    constructor(executor) {
        super(executor);
        this.openCount = 0;
    }
}
exports.RealmPromise = RealmPromise;
class RealmFactory {
    constructor(params) {
        this.syncedRealmPromises = {};
        this.discovery = params.discovery;
        this.adminToken = params.adminToken;
        this.dataPath = params.dataPath;
        this.logger = params.logger;
    }
    open(definition) {
        return __awaiter(this, void 0, void 0, function* () {
            let promise = this.syncedRealmPromises[definition.remotePath];
            if (!promise) {
                promise = new RealmPromise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    let realm;
                    let syncLabel = definition.syncLabel;
                    if (!syncLabel) {
                        const handle = yield this.discovery.waitForService("realms");
                        const realmsServiceUrl = new URI(`http://${handle.address}:${handle.port}`)
                            .segment("/realms/files/")
                            .segment(encodeURIComponent(definition.remotePath))
                            .toString();
                        while (!syncLabel) {
                            try {
                                const response = yield superagent.get(realmsServiceUrl)
                                    .set({
                                    'X-Realm-Access-Token': this.adminToken,
                                });
                                syncLabel = response.body.syncLabel;
                            }
                            catch (err) {
                                if (err.status !== 503) {
                                    return reject(err);
                                }
                            }
                        }
                        this.logger.debug(`Obtained sync label for realm at ${definition.remotePath}: ${syncLabel}`);
                    }
                    const handle = yield this.discovery.waitForService("sync", ["master", syncLabel]);
                    this.logger.debug(`Opening realm at ${definition.remotePath}: ${handle.address}:${handle.port}`);
                    const uri = new URI().host(handle.address).port(handle.port).segment(definition.remotePath);
                    realm = yield Realm.open({
                        schema: definition.schema,
                        path: definition.localPath ? path.join(this.dataPath, definition.localPath) : undefined,
                        sync: {
                            url: uri.scheme("realm").toString(),
                            user: Realm.Sync.User.adminUser(this.adminToken, uri.scheme("http").toString()),
                            error: (session, err) => {
                                this.logger.error(`Open error for realm at ${definition.remotePath}: ${err}`);
                                reject(err);
                            },
                        },
                    }).progress((a, b) => {
                        this.logger.debug(`Open progress for realm at ${definition.remotePath}: ${a}/${b}`);
                    }).then((realm) => {
                        this.logger.detail(`Opened realm at ${definition.remotePath}`);
                        const oldClose = realm.close.bind(realm);
                        realm.open = () => { promise.openCount++; };
                        realm.close = () => {
                            promise.openCount--;
                            if (promise.openCount === 0) {
                                oldClose();
                                this.logger.detail(`Closed realm at ${definition.remotePath}`);
                                delete this.syncedRealmPromises[definition.remotePath];
                            }
                        };
                        return realm;
                    });
                    const watch = this.discovery.watchService("sync", ["master", syncLabel]);
                    watch.on("available", (handle) => {
                        const uri = new URI().host(handle.address).port(handle.port).segment(definition.remotePath);
                        this.logger.detail(`Reconfiguring realm at ${definition.remotePath}: ${handle.address}:${handle.port}`);
                        const syncSession = realm.syncSession;
                        if (syncSession) {
                            syncSession._overrideServer(handle.address, handle.port);
                        }
                        else {
                            this.logger.error(`Reconfiguring realm at ${definition.remotePath} failed. Sync Session is not available.`);
                        }
                    });
                    resolve(realm);
                }));
                this.syncedRealmPromises[definition.remotePath] = promise;
            }
            promise.openCount++;
            return promise;
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
}
exports.RealmFactory = RealmFactory;
//# sourceMappingURL=RealmFactory.js.map