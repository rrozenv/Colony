"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Realm = require("realm");
const TestServer_1 = require("../TestServer");
const Logger_1 = require("../shared/Logger");
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const tmp = require("tmp");
const tar = require("tar");
const path = require("path");
const fs = require("fs-extra");
const offers = {
    revoked: "cef59ceadbe7730b1b19201fc4add7fe:1b570c4e-af64-4035-adec-bfd8dc5daf16",
    read: "cef59ceadbe7730b1b19201fc4add7fe:eb7de3ab-5c2d-49ba-8893-96576b923011",
    write: "cef59ceadbe7730b1b19201fc4add7fe:48e4cff6-3a4b-477e-966b-e219dcc5ad55",
};
function uploadWithTimeout(realm, ms) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let timeout;
            const progress = (a, b) => {
                if (a === b) {
                    realm.syncSession.removeProgressNotification(progress);
                    clearTimeout(timeout);
                    resolve(true);
                }
            };
            realm.syncSession.addProgressNotification('upload', 'forCurrentlyOutstandingWork', progress);
            timeout = setTimeout(() => {
                try {
                    realm.syncSession.removeProgressNotification(progress);
                }
                catch (e) {
                }
                resolve(false);
            }, ms);
        });
    });
}
class Expecter extends Logger_1.Logger {
    constructor(expectLines) {
        super();
        this.expected = expectLines.slice();
    }
    log(level, msg, ctx) {
        while (msg.indexOf(this.expected[0]) >= 0) {
            this.expected.shift();
        }
    }
    fulfilled() {
        return this.expected.length === 0;
    }
}
describe('Migration arguments check', function () {
    let server;
    let oldros;
    let newros;
    beforeEach(() => __awaiter(this, void 0, void 0, function* () {
        oldros = tmp.dirSync({ unsafeCleanup: true });
        newros = tmp.dirSync({ unsafeCleanup: true });
        const adir = path.join(oldros.name, "nest1", "nest2a");
        const bdir = path.join(oldros.name, "nest1", "nest2b");
        fs.mkdirpSync(adir);
        fs.mkdirpSync(bdir);
        yield tar.x({
            file: path.resolve(__dirname, "../../fixtures/old-ros-data.tar"),
            C: adir,
        });
        yield tar.x({
            file: path.resolve(__dirname, "../../fixtures/old-ros-data.tar"),
            C: bdir,
        });
        server = new TestServer_1.TestServer();
    }));
    it('should make suggestions if --from contains the root dir', () => __awaiter(this, void 0, void 0, function* () {
        const expecter = new Expecter([
            "Not a Realm Object Server root directory",
            "You probably mean one of these",
            "nest1/nest2a/root_dir",
            "nest1/nest2b/root_dir",
        ]);
        yield chai_1.assert.isRejected(server["runMigration"]({
            from: path.join(oldros.name, "nest1"),
            to: newros.name,
            copyrealms: true,
            norealms: false,
        }, expecter));
        chai_1.assert.isTrue(expecter.fulfilled());
    }));
    it('should make suggestions if --from is contained by the root dir', () => __awaiter(this, void 0, void 0, function* () {
        const expecter = new Expecter([
            "Not a Realm Object Server root directory",
            "You probably mean one of these",
            "nest1/nest2a/root_dir",
        ]);
        yield chai_1.assert.isRejected(server["runMigration"]({
            from: path.join(oldros.name, "nest1/nest2a/root_dir/0"),
            to: newros.name,
            copyrealms: true,
            norealms: false,
        }, expecter));
        chai_1.assert.isTrue(expecter.fulfilled());
    }));
    it('should fail if --to does not exist', () => __awaiter(this, void 0, void 0, function* () {
        const expecter = new Expecter([
            "The destination should be an empty directory",
        ]);
        yield chai_1.assert.isRejected(server["runMigration"]({
            from: path.join(oldros.name, "nest1/nest2a/root_dir"),
            to: path.join(newros.name, "asd"),
            copyrealms: true,
            norealms: false,
        }, expecter));
        chai_1.assert.isTrue(expecter.fulfilled());
    }));
    it('should fail if --to is not empty', () => __awaiter(this, void 0, void 0, function* () {
        fs.mkdirSync(path.join(newros.name, "asd"));
        const expecter = new Expecter([
            "The destination should be an empty directory",
        ]);
        yield chai_1.assert.isRejected(server["runMigration"]({
            from: path.join(oldros.name, "nest1/nest2a/root_dir"),
            to: newros.name,
            copyrealms: true,
            norealms: false,
        }, expecter));
        chai_1.assert.isTrue(expecter.fulfilled());
    }));
    it('should fail if --to is a file', () => __awaiter(this, void 0, void 0, function* () {
        const filename = path.join(newros.name, "asd");
        fs.writeFileSync(filename, "");
        const expecter = new Expecter([
            "The destination should be an empty directory",
        ]);
        yield chai_1.assert.isRejected(server["runMigration"]({
            from: path.join(oldros.name, "nest1/nest2a/root_dir"),
            to: filename,
            copyrealms: true,
            norealms: false,
        }, expecter));
        chai_1.assert.isTrue(expecter.fulfilled());
    }));
    it('should fail if --from not specified', () => __awaiter(this, void 0, void 0, function* () {
        yield chai_1.assert.isRejected(server["runMigration"]({
            from: path.join(oldros.name, "nest1/nest2a/root_dir"),
            to: undefined,
            copyrealms: true,
            norealms: true,
        }, new Logger_1.Mute()), Error, "Please specify both --from and --to. Aborting.");
    }));
    it('should fail if --to not specified', () => __awaiter(this, void 0, void 0, function* () {
        yield chai_1.assert.isRejected(server["runMigration"]({
            from: undefined,
            to: newros.name,
            copyrealms: true,
            norealms: true,
        }, new Logger_1.Mute()), Error, "Please specify both --from and --to. Aborting.");
    }));
    it('should fail if both --copyrealms and --norealms are specified', () => __awaiter(this, void 0, void 0, function* () {
        yield chai_1.assert.isRejected(server["runMigration"]({
            from: path.join(oldros.name, "nest1/nest2a/root_dir"),
            to: newros.name,
            copyrealms: true,
            norealms: true,
        }, new Logger_1.Mute()), Error, "Cannot have both --copyrealms and --norealms at the same time. Aborting.");
    }));
    it('should skip invalid and non-existent realms', () => __awaiter(this, void 0, void 0, function* () {
        const frompath = path.join(oldros.name, "nest1/nest2a/root_dir");
        const nonexistentPath = path.resolve(frompath, "0", "user_data", "non-existent.realm");
        const expecter = new Expecter([
            "skipping a realm with invalid path: /cÃ¦t",
            `will not copy user realm ${nonexistentPath}: does not exist`,
        ]);
        yield chai_1.assert.isFulfilled(server["runMigration"]({
            from: frompath,
            to: newros.name,
            copyrealms: true,
            norealms: false,
        }, expecter));
        chai_1.assert.isTrue(expecter.fulfilled());
    }));
    afterEach(() => __awaiter(this, void 0, void 0, function* () {
        oldros.removeCallback();
        newros.removeCallback();
    }));
});
describe('Migration', function () {
    let server;
    let user;
    let oldros;
    let readurl;
    let writeurl;
    let newros;
    before(() => __awaiter(this, void 0, void 0, function* () {
        oldros = tmp.dirSync({ unsafeCleanup: true });
        newros = tmp.dirSync({ unsafeCleanup: true });
        yield tar.x({
            file: path.resolve(__dirname, "../../fixtures/old-ros-data.tar"),
            C: oldros.name,
        });
        server = new TestServer_1.TestServer();
        yield server["runMigration"]({
            from: path.join(oldros.name, "root_dir"),
            to: newros.name,
            copyrealms: true,
            norealms: false,
        }, new Logger_1.Mute());
        yield server.start({
            dataPath: newros.name,
            privateKeyPath: path.join(oldros.name, "keys", "token-signature.key"),
            publicKeyPath: path.join(oldros.name, "keys", "token-signature.pub"),
            autoKeyGen: false,
        });
        user = yield Realm.Sync.User.login(server.url, 'bob', 'b0b');
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown();
        oldros.removeCallback();
        newros.removeCallback();
    }));
    describe("After migration, bob", () => {
        it("should not be able to accept the revoked offer", () => __awaiter(this, void 0, void 0, function* () {
            yield chai_1.assert.isRejected(user.acceptPermissionOffer(offers.revoked));
        }));
        it.skip("should be able accept the read offer", () => __awaiter(this, void 0, void 0, function* () {
            readurl = yield user.acceptPermissionOffer(offers.read);
        }));
        it.skip("shoule be able the write offer", () => __awaiter(this, void 0, void 0, function* () {
            writeurl = yield user.acceptPermissionOffer(offers.write);
        }));
        const aliceID = 'cef59ceadbe7730b1b19201fc4add7fe';
        function canRead(name, absolute = false) {
            return __awaiter(this, void 0, void 0, function* () {
                let realm;
                try {
                    yield new Promise((resolve, reject) => {
                        realm = new Realm({
                            path: path.join(server.dataPath, `${name}-${absolute}.realm`),
                            sync: {
                                url: `realm://${server.address}/${absolute ? '' : aliceID + '/'}${name}`,
                                user,
                                error: (a, b) => {
                                    realm.close();
                                    realm = null;
                                    reject(b.message);
                                },
                            },
                            schema: [{ name: 'Item', properties: { id: 'int', name: 'string' } }],
                        });
                        realm.syncSession.addProgressNotification('download', 'forCurrentlyOutstandingWork', (a, b) => {
                            if (a === b) {
                                resolve();
                            }
                        });
                    });
                    return realm.objects('Item').length === 10;
                }
                catch (e) {
                    return false;
                }
                finally {
                    if (realm) {
                        realm.close();
                    }
                }
            });
        }
        function canWrite(name, absolute = false) {
            return __awaiter(this, void 0, void 0, function* () {
                let realm;
                try {
                    const can = yield new Promise((resolve, reject) => {
                        realm = new Realm({
                            path: path.join(server.dataPath, `${name}-${absolute}.realm`),
                            sync: {
                                url: `realm://${server.address}/${absolute ? '' : aliceID + '/'}${name}`,
                                user,
                                error: (a, b) => {
                                    realm.close();
                                    realm = null;
                                    reject(b.message);
                                },
                            },
                            schema: [{ name: 'Item', properties: { id: 'int', name: 'string' } }],
                        });
                        realm.write(() => {
                            realm.create('Item', { id: 10, name: 'world' });
                        });
                        uploadWithTimeout(realm, 1000).then(resolve);
                    });
                    return can;
                }
                catch (e) {
                    return false;
                }
                finally {
                    if (realm) {
                        realm.close();
                    }
                }
            });
        }
        describe("for realm /4anyr", () => {
            it("can read the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isTrue(yield canRead('4anyr', true));
            }));
            it.skip("cannot write the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield canWrite('4anyr', true));
            }));
        });
        describe("for realm 4bobr", () => {
            it("can read the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isTrue(yield canRead('4bobr'));
            }));
            it.skip("cannot write the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield canWrite('4bobr'));
            }));
        });
        describe("for realm 4anyr", () => {
            it.skip("can read the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isTrue(yield canRead('4anyr'));
            }));
            it("cannot write the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield canWrite('4anyr'));
            }));
        });
        describe("for realm 4bobrw", () => {
            it.skip("can write the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isTrue(yield canWrite('4bobrw'));
            }));
        });
        describe("for realm private", () => {
            it.skip("cannot read the realm", () => __awaiter(this, void 0, void 0, function* () {
                chai_1.assert.isFalse(yield canRead('private'));
            }));
        });
    });
});
//# sourceMappingURL=migration.spec.js.map