"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const TestServer_1 = require("../TestServer");
const auth = require("../auth");
const Token_1 = require("../shared/Token");
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const superagent = require("superagent");
describe('Auth Service Integration Tests', function () {
    let server;
    let authService;
    let provider;
    before(() => __awaiter(this, void 0, void 0, function* () {
        server = new TestServer_1.TestServer();
        provider = new auth.DebugAuthProvider();
        yield server.start({
            authProviders: [provider]
        });
        authService = server.getService('auth');
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown();
    }));
    describe("POST /auth (authenticate)", () => {
        describe("without provider", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(superagent.post(`${server.url}/auth`).send({}), "Bad Request");
            }));
        });
        describe("with unknown provider", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(superagent.post(`${server.url}/auth`).send({
                    provider: "snapchat",
                }), "Bad Request");
            }));
        });
        describe("without data", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(superagent.post(`${server.url}/auth`).send({
                    provider: "debug",
                }), "Bad Request");
            }));
        });
        describe("with data = 'admin' (debug provider)", () => {
            it("should return a regular user refresh token", () => __awaiter(this, void 0, void 0, function* () {
                const response = yield chai_1.assert.isFulfilled(superagent.post(`${server.url}/auth`).send({
                    provider: "debug",
                    data: "admin"
                }));
                const refreshToken = response.body.refresh_token;
                chai_1.assert.isString(refreshToken.token);
                chai_1.assert.isTrue(refreshToken.token_data.is_admin);
            }));
        });
        describe("with data = 'not-an-admin' (debug provider)", () => {
            it("should return a regular user refresh token", () => __awaiter(this, void 0, void 0, function* () {
                const response = yield chai_1.assert.isFulfilled(superagent.post(`${server.url}/auth`).send({
                    provider: "debug",
                    data: "not-an-admin"
                }));
                const refreshToken = response.body.refresh_token;
                chai_1.assert.isString(refreshToken.token);
                chai_1.assert.isFalse(refreshToken.token_data.is_admin);
            }));
        });
    });
    describe("POST /auth/revoke (revokeToken)", () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            const token = new Token_1.RefreshToken({
                isAdmin: false,
                identity: "some-identity",
                appId: 'io.realm.Test',
                expires: Math.round(Date.now() / 1000) + 60,
            });
        }));
        describe("with regular user refresh token", () => {
            let token;
            beforeEach(() => {
                token = new Token_1.RefreshToken({
                    isAdmin: false,
                    identity: "some-identity",
                    appId: 'io.realm.Test',
                    expires: Math.round(Date.now() / 1000) + 60,
                });
            });
            describe("without a token field", () => {
                it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                    yield chai_1.assert.isRejected(superagent.post(`${server.url}/auth/revoke`).set({
                        Authorization: token.sign(server.privateKey),
                    }).send({}), "Bad Request");
                }));
            });
            it("should revoke a token", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isFulfilled(superagent.post(`${server.url}/auth/revoke`).set({
                    Authorization: token.sign(server.privateKey),
                }).send({
                    token: token.sign(server.privateKey),
                }));
                yield chai_1.assert.isRejected(superagent.post(`${server.url}/auth/revoke`).set({
                    Authorization: token.sign(server.privateKey),
                }).send({
                    token: token.sign(server.privateKey),
                }), "Forbidden");
            }));
        });
        describe("with admin user refresh token", () => {
            let adminToken;
            let token;
            beforeEach(() => {
                adminToken = new Token_1.RefreshToken({
                    isAdmin: true,
                    identity: "admin",
                    appId: 'io.realm.Test',
                    expires: Math.round(Date.now() / 1000) + 60,
                });
                token = new Token_1.RefreshToken({
                    isAdmin: false,
                    identity: "some-user-2",
                    appId: 'io.realm.Test',
                    expires: Math.round(Date.now() / 1000) + 60,
                });
            });
            it("should revoke a token", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isFulfilled(superagent.post(`${server.url}/auth/revoke`).set({
                    Authorization: adminToken.sign(server.privateKey),
                }).send({
                    token: token.sign(server.privateKey),
                }));
                yield chai_1.assert.isRejected(superagent.post(`${server.url}/auth/revoke`).set({
                    Authorization: token.sign(server.privateKey),
                }).send({
                    token: token.sign(server.privateKey),
                }), "Forbidden");
            }));
        });
    });
});
//# sourceMappingURL=auth-service-integration-tests.spec.js.map