"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const TestServer_1 = require("../../TestServer");
const auth = require("../../auth");
const Token_1 = require("../../shared/Token");
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const superagent = require("superagent");
const Realm = require("realm");
const uuid = require("uuid");
const URI = require("urijs");
describe('PermissionsService Default Access Integration Tests', function () {
    let server;
    let authService;
    let provider;
    let authAccessTokenUrl;
    before(() => __awaiter(this, void 0, void 0, function* () {
        server = new TestServer_1.TestServer();
        provider = new auth.PasswordAuthProvider({ iterations: 1 });
        yield server.start({
            authProviders: [provider]
        });
        authService = server.getService('auth');
        authAccessTokenUrl = new URI(server.url).segment('auth').toString();
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown();
    }));
    describe("a regular user creation of ~/myrealm for first time", () => {
        describe("when realm file doesn't exist", () => {
            it("should have download, upload, and manage access", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield Realm.Sync.User.register(server.url, uuid.v4(), 'samplepassword');
                const userRefreshToken = user.token;
                const response = yield superagent
                    .post(authAccessTokenUrl)
                    .send({
                    path: `~/myrealm${uuid.v4()}`,
                    data: userRefreshToken,
                    provider: 'realm'
                });
                chai_1.expect(response.body["access_token"]).to.be.not.undefined;
                chai_1.expect(response.body["access_token"]["token_data"]).to.be.not.undefined;
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.exist;
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.include('download');
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.include('upload');
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.include('manage');
            }));
        });
    });
    describe("a regular user creation of global realm for first time", () => {
        describe("when realm file doesn't exist", () => {
            it("should throw a 403 Access Denied Error", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield authService.createOrUpdateUser(uuid.v4(), "debug", false);
                const userRefreshToken = new Token_1.RefreshToken({
                    isAdmin: false,
                    identity: user.userId,
                    appId: 'io.realm.Auth',
                }).sign(server.privateKey);
                try {
                    const response = yield superagent
                        .post(authAccessTokenUrl)
                        .send({
                        path: '/someglobalrealm',
                        data: userRefreshToken,
                        provider: 'realm'
                    });
                }
                catch (err) {
                    chai_1.expect(err['status']).to.eq(403);
                }
            }));
        });
    });
    describe("an admin user creation of ~/myrealm for first time", () => {
        describe("when realm file doesn't exist", () => {
            it("should have download, upload, manage access", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield authService.createOrUpdateUser(uuid.v4(), "debug", false);
                const userRefreshToken = new Token_1.RefreshToken({
                    isAdmin: true,
                    identity: user.userId,
                    appId: 'io.realm.Auth',
                }).sign(server.privateKey);
                const response = yield superagent
                    .post(authAccessTokenUrl)
                    .send({
                    path: `/someglobalrealm-${uuid.v4()}`,
                    data: userRefreshToken,
                    provider: 'realm'
                });
                chai_1.expect(response.body["access_token"]).to.be.not.undefined;
                chai_1.expect(response.body["access_token"]["token_data"]).to.be.not.undefined;
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.exist;
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.include('download');
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.include('upload');
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.include('manage');
            }));
        });
    });
    describe("an admin user creation of global realm for first time", () => {
        describe("when realm file doesn't exist", () => {
            it("should have download, upload, and manage access", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield authService.createOrUpdateUser(uuid.v4(), "debug", false);
                const userRefreshToken = new Token_1.RefreshToken({
                    isAdmin: true,
                    identity: user.userId,
                    appId: 'io.realm.Auth',
                }).sign(server.privateKey);
                const response = yield superagent
                    .post(authAccessTokenUrl)
                    .send({
                    path: `/someglobalrealm-${uuid.v4()}`,
                    data: userRefreshToken,
                    provider: 'realm'
                });
                chai_1.expect(response.body["access_token"]).to.be.not.undefined;
                chai_1.expect(response.body["access_token"]["token_data"]).to.be.not.undefined;
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.exist;
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.include('download');
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.include('upload');
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.include('manage');
            }));
        });
    });
});
//# sourceMappingURL=permission-service-default-access-integration-tests.spec.js.map