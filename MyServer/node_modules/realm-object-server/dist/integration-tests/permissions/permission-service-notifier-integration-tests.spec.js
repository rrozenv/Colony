"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const TestServer_1 = require("../../TestServer");
const realms_1 = require("../../realms");
const chai_1 = require("chai");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const superagent = require("superagent");
const Realm = require("realm");
const uuid = require("uuid");
const URI = require("urijs");
const ProductSchema = {
    name: 'Product',
    primaryKey: 'productId',
    properties: {
        productId: { type: 'int', optional: false },
        name: { type: 'string', optional: false },
        price: { type: 'float', optional: false }
    }
};
describe('PermissionsService Global Notifier Integration Tests', function () {
    let server;
    let authService;
    let permissionService;
    let authAccessTokenUrl;
    before(() => __awaiter(this, void 0, void 0, function* () {
        server = new TestServer_1.TestServer();
        yield server.start();
        authAccessTokenUrl = new URI(server.url).segment('auth').toString();
        permissionService = server.getService('permissions');
    }));
    after(() => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown();
    }));
    describe("a regular user creation of ~/myrealm for first time", () => {
        describe("when realm file doesn't exist", () => {
            it("should create a RealmFile <Permission> entry with mayWrite mayManage and mayRead", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield Realm.Sync.User.register(server.url, uuid.v4(), 'samplepassword');
                const userRefreshToken = user.token;
                const accessTokenResponse = yield superagent
                    .post(authAccessTokenUrl)
                    .send({
                    path: `/~/myrealm`,
                    data: userRefreshToken,
                    provider: 'realm'
                });
                const path = accessTokenResponse.body['access_token']['token_data']['path'];
                const adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
                const realmFileInstance = adminRealm.objectForPrimaryKey("RealmFile", path);
                chai_1.expect(realmFileInstance).to.exist;
                chai_1.expect(realmFileInstance.permissions[0]).to.exist;
                chai_1.expect(realmFileInstance.permissions[0].user.userId).to.be.eq(user.identity);
                chai_1.expect(realmFileInstance.permissions[0].mayManage).to.be.true;
                chai_1.expect(realmFileInstance.permissions[0].mayRead).to.be.true;
                chai_1.expect(realmFileInstance.permissions[0].mayWrite).to.be.true;
                yield new Promise((resolve, reject) => {
                    setTimeout(resolve, 500);
                });
                let realm = yield permissionService.getUserSpecificPermissionRealm(user.identity);
                const userSpecificPermissions = realm.objects('Permission')
                    .filtered('path = $0', path);
                chai_1.expect(userSpecificPermissions[0]).to.exist;
                chai_1.expect(userSpecificPermissions[0].userId).to.eq(user.identity);
                chai_1.expect(userSpecificPermissions[0].path).to.eq(path);
                chai_1.expect(userSpecificPermissions[0].mayManage).to.eq(realmFileInstance.permissions[0].mayManage);
                chai_1.expect(userSpecificPermissions[0].mayWrite).to.eq(realmFileInstance.permissions[0].mayWrite);
                chai_1.expect(userSpecificPermissions[0].mayRead).to.eq(realmFileInstance.permissions[0].mayRead);
                adminRealm.close();
                realm.close();
            }));
            it("should create a /~/__permission entry upon requesting for the realm", () => __awaiter(this, void 0, void 0, function* () {
                const user = yield Realm.Sync.User.register(server.url, uuid.v4(), 'samplepassword');
                const userRefreshToken = user.token;
                const response = yield superagent
                    .post(authAccessTokenUrl)
                    .send({
                    path: `/~/__permission`,
                    data: userRefreshToken,
                    provider: 'realm'
                });
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.exist;
                chai_1.expect(response.body["access_token"]["token_data"]["access"]).to.include('download');
                const path = response.body["access_token"]["token_data"]["path"];
                const adminRealm = yield server.realmFactory.open(realms_1.AdminRealm);
                const realmFile = adminRealm.objectForPrimaryKey('RealmFile', path);
                chai_1.expect(realmFile).to.exist;
                chai_1.expect(realmFile.path).to.eq(path);
                adminRealm.close();
            }));
        });
    });
    describe("a PermissionChange should initiate a propogation effect", () => {
        it('should mutate the RealmFile.permission collection', () => __awaiter(this, void 0, void 0, function* () {
            const userA = yield Realm.Sync.User.register(server.url, uuid.v4(), 'samplepassword');
            const userB = yield Realm.Sync.User.register(server.url, uuid.v4(), 'samplepassword');
            const realmA = new Realm({
                sync: {
                    user: userA,
                    url: `realm://${server.address}/~/products`
                },
                schema: [ProductSchema]
            });
            realmA.write(() => {
                realmA.create('Product', {
                    productId: 1,
                    name: 'something',
                    price: 56930.66
                });
            });
            const condition = { userId: userB.identity };
            const r = yield userA.applyPermissions(condition, "/~/products", 'read');
            chai_1.expect(r.mayRead).to.be.true;
        }));
    });
    describe("a PermissionOffer should create a /~/management realm object", () => {
        it('should mutate the RealmFile.permission collection', () => __awaiter(this, void 0, void 0, function* () {
            const userA = yield Realm.Sync.User.register(server.url, uuid.v4(), 'samplepassword');
            const userB = yield Realm.Sync.User.register(server.url, uuid.v4(), 'samplepassword');
            const realmA = new Realm({
                sync: {
                    user: userA,
                    url: `realm://${server.address}/~/products`
                },
                schema: [ProductSchema]
            });
            realmA.write(() => {
                realmA.create('Product', {
                    productId: 1,
                    name: 'something',
                    price: 56930.66
                });
            });
            const condition = { userId: userB.identity };
            const res = yield userA.offerPermissions(`realm://${server.address}/~/products`, 'read');
            yield new Promise((resolve, reject) => {
                setTimeout(resolve, 500);
            });
            let managementRealm = yield permissionService.getManagementRealmForUserId(userA.identity);
            const permissionOffer = managementRealm.objects(realms_1.PermissionOffer.schema.name)
                .filtered('token = $0', res)[0];
            chai_1.expect(permissionOffer).to.exist;
            managementRealm.close();
        }));
    });
});
//# sourceMappingURL=permission-service-notifier-integration-tests.spec.js.map