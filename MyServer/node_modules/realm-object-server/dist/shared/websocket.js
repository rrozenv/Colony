"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const uws = require("uws");
const errors = require("../errors");
const Token_1 = require("./Token");
class ServiceWebSocketServer extends uws.Server {
    constructor(publicKey, logger) {
        super({ noServer: true });
        this.publicKey = publicKey;
        this.logger = logger;
    }
    setLogger(logger) {
        this.logger = logger;
    }
    upgradeAuthenticated(req, socket, head, mustBeAdmin = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.upgradeWebSocket(req, socket, head);
            const authenticatedClient = new Promise((resolve, reject) => {
                client.on('message', message => {
                    try {
                        const isValid = this.isValidFirstMessage(message, mustBeAdmin);
                        if (isValid) {
                            resolve(client);
                        }
                        else {
                            throw new Error(`Not a valid first message`);
                        }
                    }
                    catch (err) {
                        if (err instanceof SyntaxError) {
                            err = new errors.realm.InvalidCredentials({
                                title: 'Expected a serialized JSON object as the first message'
                            });
                        }
                        reject(err);
                    }
                });
            });
            return Promise.race([
                authenticatedClient,
                this.timeout(ServiceWebSocketServer.AUTHENTICATION_TIMEOUT),
            ]).catch(err => {
                this.logger.debug(`Couldn't upgrade WebSocket: ${err.message}`);
                if (client.readyState === uws.OPEN || client.readyState === uws.CONNECTING) {
                    client.close(1008, err.message);
                }
                throw err;
            });
        });
    }
    isValidFirstMessage(message, mustBeAdmin) {
        const msg = JSON.parse(message);
        if (!msg.action) {
            throw new errors.realm.MissingParameters('action');
        }
        if (msg.action === 'authenticate') {
            if (!msg.token) {
                throw new errors.realm.MissingParameters('token');
            }
            const token = this.parseToken(msg.token);
            if (token instanceof Token_1.RefreshToken) {
                if (mustBeAdmin && !token.isAdmin) {
                    throw new errors.realm.InvalidCredentials({
                        title: 'Expected an admin'
                    });
                }
                else {
                    return true;
                }
            }
            else if (token instanceof Token_1.AccessToken) {
                if (mustBeAdmin && token.identity !== '__admin') {
                    throw new errors.realm.InvalidCredentials({
                        title: 'Expected an admin'
                    });
                }
                else {
                    return true;
                }
            }
            else {
                throw new errors.realm.InvalidCredentials({
                    title: 'Unexpected token'
                });
            }
        }
        else {
            const example = '{ action: "authenticate", ... }';
            throw new errors.realm.InvalidCredentials({
                title: `Expected an authentication message: ${example}`
            });
        }
    }
    upgradeWebSocket(req, socket, head) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.handleUpgrade(req, socket, head, (client) => {
                    resolve(client);
                });
            });
        });
    }
    timeout(timeout) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                const err = new errors.realm.InvalidCredentials({
                    title: `Expected an authentication message within the first ${timeout}ms`,
                });
                reject(err);
            }, timeout);
        });
    }
    parseToken(token) {
        return Token_1.Token.parse(token, this.publicKey);
    }
}
ServiceWebSocketServer.AUTHENTICATION_TIMEOUT = 1000;
exports.ServiceWebSocketServer = ServiceWebSocketServer;
//# sourceMappingURL=websocket.js.map