"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const virtPath_1 = require("./virtPath");
const errors = require("../errors");
const URI = require("urijs");
function Promisify(callback, ...args) {
    return new Promise((resolve, reject) => {
        callback(...args, (err, result) => {
            if (err)
                reject(err);
            else {
                resolve(result);
            }
        });
    });
}
exports.Promisify = Promisify;
class TimeoutError extends Error {
    constructor(ms) {
        super(`Operation failed to complete within ${ms}ms`);
        this.ms = ms;
    }
}
exports.TimeoutError = TimeoutError;
function timeout(promise, ms) {
    const timeoutPromise = new Promise((resolve, reject) => {
        let id = setTimeout(() => {
            clearTimeout(id);
            reject(new TimeoutError(ms));
        }, ms);
    });
    return Promise.race([promise, timeoutPromise]);
}
exports.timeout = timeout;
function validateRealmPath(path, token) {
    if (!path) {
        throw new errors.realm.MissingParameters('path');
    }
    let decodedPath = URI.decode(path);
    if (decodedPath.includes('~')) {
        if (token.identity) {
            decodedPath = decodedPath.replace('~', token.identity);
        }
        else {
            throw new errors.realm.InvalidParameters({
                name: 'path',
                reason: `path cannot contain a ~. Please use a full absolute path when trying to find the realmFile.`
            });
        }
    }
    if (!decodedPath.startsWith('/')) {
        decodedPath = '/' + decodedPath;
    }
    if (!virtPath_1.mapVirtToRealmPath("/", decodedPath)) {
        throw new errors.realm.InvalidParameters({
            name: 'path',
            reason: `path is invalid. It should start with a slash, consist of Latin letters (A-Z, a-z), digits (0-9), dot (.), dash (-), and underscore (_). All components should be non-empty and not start with a dot. The path should not end with .realm, .realm.lock or .realm.management.`
        });
    }
    return decodedPath;
}
exports.validateRealmPath = validateRealmPath;
function waitForDownload(realm) {
    return new Promise((resolve, reject) => {
        realm.syncSession.addProgressNotification('download', 'forCurrentlyOutstandingWork', (downloaded, downloadable) => {
            if (downloaded === downloadable) {
                resolve();
            }
        });
    });
}
exports.waitForDownload = waitForDownload;
//# sourceMappingURL=util.js.map